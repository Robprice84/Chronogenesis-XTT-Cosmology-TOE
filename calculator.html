<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronogenesis Mass Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/decimal.js@10.4.3/decimal.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #display, .formula, .mode-indices, .full-index-display {
            font-family: 'JetBrains Mono', monospace;
        }
        /* Ensure the image scales correctly */
        .responsive-img {
            max-width: 100%;
            height: auto;
        }
        /* Removed max-height and overflow-y for mode-indices to show all content */
        .mode-indices {
            /* max-height: 300px; */ /* Removed */
            /* overflow-y: auto; */ /* Removed */
            cursor: default; /* Default cursor for the container */
            word-break: break-all; /* Ensure long numbers wrap */
        }
        /* Container for each particle item */
        .mode-index-item-container {
            border-bottom: 1px solid #2f3b4a; /* Subtle separator */
            padding: 4px 0; /* Add some padding */
        }
        .mode-index-item-container:last-child {
            border-bottom: none; /* No border on the last item */
        }
        /* Style for clickable particle name */
        .mode-index-item {
            transition: background-color 0.2s ease;
            cursor: pointer; /* Indicate items are clickable */
            padding: 2px 0; /* Smaller padding for the clickable name */
        }
        .mode-index-item:hover {
            background-color: #2f3b4a; /* Highlight on hover */
        }
        /* Style for the displayed full mode index */
        .full-index-display {
            margin-top: 5px; /* Space below the name */
            padding: 8px; /* Padding inside the display box */
            background-color: #2f3b4a;
            border-radius: 6px;
            font-size: 0.9em;
            word-break: break-all;
            display: none; /* Hidden by default */
        }

        /* Custom scrollbar styles (still included but won't be active without overflow-y) */
        .mode-indices::-webkit-scrollbar {
            width: 8px;
        }
        .mode-indices::-webkit-scrollbar-track {
            background: #1f2833;
            border-radius: 10px;
        }
        .mode-indices::-webkit-scrollbar-thumb {
            background: #45a29e;
            border-radius: 10px;
        }
        .mode-indices::-webkit-scrollbar-thumb:hover {
            background: #66fcf1;
        }
        /* Added min-height to the display area to prevent jumping */
        #display {
            min-height: 200px; /* Adjust this value as needed */
            overflow-y: auto; /* Add scrollbar if content exceeds height */
            max-width: 100%; /* Ensure it doesn't exceed container width */
            box-sizing: border-box; /* Include padding and border in the element's total width */
        }
         /* Custom scrollbar for the display area */
        #display::-webkit-scrollbar {
            width: 8px;
        }
        #display::-webkit-scrollbar-track {
            background: #1f2833;
            border-radius: 10px;
        }
        #display::-webkit-scrollbar-thumb {
            background: #45a29e;
            border-radius: 10px;
        }
        #display::-webkit-scrollbar-thumb:hover {
            background: #66fcf1;
        }

        /* Style for the info section */
        .info-section {
            margin-top: 20px;
            padding: 15px;
            background-color: #2f3b4a;
            border-radius: 8px;
            color: #c5c6c7;
            font-size: 0.9em;
        }
        .info-section strong {
            color: #66fcf1;
        }
         .warning {
            color: #ffcc00; /* Yellow/Orange color for warnings */
            font-weight: bold;
         }
         .error-message {
            color: #ff0000; /* Red color for errors */
            font-weight: bold;
         }
         .highlight-green {
            color: #00ff88; /* Green color for highlights */
         }
         .spin-formulation {
             margin-top: 20px;
             padding: 15px;
             background-color: #2f3b4a;
             border-radius: 8px;
             color: #c5c6c7;
             font-size: 0.9em;
         }
         .spin-formulation strong {
             color: #66fcf1;
         }
         .spin-formulation code {
             display: block;
             margin: 10px 0;
             padding: 10px;
             background-color: #1f2833;
             border-radius: 4px;
             overflow-x: auto; /* Add horizontal scroll for long formulas */
         }
          /* LaTeX rendering for math */
          .latex-math {
              display: inline-block;
              white-space: nowrap; /* Prevent line breaks within math */
              overflow-x: auto; /* Allow horizontal scroll for long equations */
              vertical-align: middle; /* Align with surrounding text */
          }
    </style>
     <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body class="bg-[#0b0c10] text-[#ffffff] flex justify-center items-center min-h-screen p-4 overflow-x-hidden">
    <div class="calculator bg-[#1f2833] rounded-2xl p-8 shadow-2xl w-full max-w-6xl flex flex-col md:flex-row">
        <div class="left flex-1 md:pr-8 md:border-r-2 md:border-[#c5c6c7] mb-8 md:mb-0">
            <div class="title text-3xl md:text-4xl mb-6 text-[#66fcf1] text-center font-bold">Chronogenesis Mass Calculator</div>

            <div id="display" class="screen bg-[#45a29e] text-[#1f2833] p-6 rounded-xl text-lg mb-6 min-h-[200px] overflow-wrap break-word leading-relaxed">
                Select a particle or prediction to view data.<br>
                <span class="text-sm text-[#1f2833]">This calculator uses the Chronogenesis model to predict fundamental particle properties based on their mode index (n) and a time-curvature relationship (κ).</span>
            </div>

            <div id="confirm-bar" class="confirm-bar text-center mb-6"></div>

            <div id="buttonGrid" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
                </div>

            <div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-3 gap-4 mt-6">
                <button onclick="customN()" class="p-3 rounded-lg font-bold bg-[#c5c6c7] text-[#1f2833] hover:bg-[#66fcf1] transition duration-200">CUSTOM n</button>
                <button onclick="clearDisplay()" class="p-3 rounded-lg font-bold bg-[#c5c6c7] text-[#1f2833] hover:bg-[#66fcf1] transition duration-200">CLEAR</button>
                <button onclick="showFormula()" class="p-3 rounded-lg font-bold bg-[#c5c6c7] text-[#1f2833] hover:bg-[#66fcf1] transition duration-200">FORMULA</button>
            </div>

            <div class="info-section">
                <strong>About the Chronogenesis Model:</strong>
                <p class="mt-2">This calculator is based on the Chronogenesis model, which proposes that fundamental particle properties are quantized energy states (modes) of a universal time-curvature field (Θ). The mass spectrum and other properties are derived from the eigenmodes of this field. This tool allows for the calculation of these properties based on the mode index (n) and the time-curvature relationship (κ).</p>
                 <p class="mt-2 text-sm italic">
                    Properties calculated by this tool:
                    <ul>
                        <li><strong>Mass (m<sub>n</sub>):</strong> Predicted from the mode index (n) and time-curvature (κ).</li>
                         <li><strong>Time-Curvature Mode (κ<sub>n</sub>):</strong> A unitless value representing the particle's mode in the time-curvature field.</li>
                         <li><strong>Predicted Spin:</strong> Derived from the topological winding number of the Θ-field eigenmode over a compactified time dimension. This links spin to the fundamental geometry of the field. (Note: This is a model prediction and may not always match the Standard Model spin).</li>
                        <li><strong>Charge (Placeholder/Manual Entry):</strong> The electric charge assigned to the particle mode within the Chronogenesis framework. (Note: Charge is assigned based on the model's framework, not directly predicted by the core mass/kappa formula).</li>
                        <li><strong>Stability/Lifetime:</strong> Resonant stability valleys in the mass spectrum (where the second derivative of mass is near zero) predict longer-lived particles and stable decays. Off-valley modes correspond to unstable resonances.</li>
                         <li><strong>Redshift Origin (z):</strong> Each mode index (n) is linked to a predicted cosmological redshift (z), potentially connecting particles to cosmic structures.</li>
                         <li><strong>Quantum Decoherence Time (τ<sub>D</sub>):</strong> The model provides a formula for the collapse time of superpositions involving a mode based on the difference in the Θ field. (Note: Calculation here uses a simplified $\Delta\kappa = \kappa_n$ and $\Theta=1$).</li>
                         <li><strong>Entropy Contribution (S<sub>n</sub>):</strong> Each particle mode has an associated entropy value ($S_n$).</li>
                         <li><strong>Resonance Shell Layer (k):</strong> Each mode index corresponds to a predicted cosmic shell layer index (k), indicating a particle's position within large-scale cosmic structure.</li>
                    </ul>
                     Other aspects of the broader theory, such as calculating charge directly from topology, visualizing field geometry, and calculating interaction strengths for composite particles, are addressed in theoretical papers or separate tools and are beyond the scope of this calculator.
                </p>
            </div>


            <div class="footer mt-8 text-sm text-[#888] text-center">
                CNG: Particle masses validated against PDG/CODATA references. All predicted values arise from a single eigenmode curve (n, λ, κₙ) defined in the Chronogenesis v1.2 dataset.
            </div>
        </div>

        <div class="right flex-1 md:pl-8">
            <div class="mt-8 text-center md:mt-0"> <img src="chronogenesis_eigenmode_curve.png" alt="Eigenmode Curve" class="responsive-img rounded-xl border border-[#444]">
            </div>

            <div class="mt-8 bg-[#0b0c10] text-[#ccc] p-6 rounded-xl text-sm leading-relaxed mode-indices" id="modeIndicesListContainer">
                <strong class="text-[#66fcf1] text-base block mb-2">Refined Mode Indices (n):</strong>
                </div>

            <div id="formulaDisplay" class="formula bg-[#1f2833] text-[#66fcf1] p-6 rounded-xl text-lg overflow-wrap break-word hidden mt-6">
                <strong class="text-xl block mb-2">Chronogenesis Mass Formula:</strong>
                <code class="block mb-4">
                    $$m_n = \alpha \cdot \sqrt{\kappa_n}$$
                </code>
                <p class="mb-2">Where:</p>
                <code class="block">
                    $$\kappa_n = n^{0.618} \cdot \log(n + 1)$$
                    <span class="text-sm text-[#c5c6c7]">(Time-Curvature Mode, unitless)</span><br>
                    $m_n$ = Mass of the particle mode (in kg or MeV/c<sup>2</sup>)<br>
                    $n$ = Mode index (a large integer)<br>
                    $\alpha$ = Mass scaling constant (calibrated from the electron mass)<br>
                    $\log()$ = Natural logarithm
                </code>
                <p class="mt-4 text-sm text-[#c5c6c7]">
                    This formula relates the quantized mass ($m_n$) of a fundamental particle to its mode index ($n$) through the time-curvature mode ($\kappa_n$). The constant $\alpha$ is determined empirically using a known particle mass (currently the electron).
                </p>

                <div class="spin-formulation mt-8">
                    <strong class="text-xl block mb-2">Topological Spin from Temporal Winding:</strong>
                    <p class="mb-2">
                        Spin ($s_n$) emerges from the winding number ($W_n$) of the $\Theta$-field eigenmode ($\Theta_n$) over compactified time ($x^0 \in [0, 2\pi L]$).
                    </p>
                    <p class="mb-2">
                        Winding number ($W_n$) is the path integral of the field's gradient:
                    </p>
                    <code class="block mb-4">
                        $$W_n = \oint_{S^1} \partial_\mu \Theta_n(x) \, dx^\mu$$
                    </code>
                    <p class="mb-2">
                        For a time-like loop:
                    </p>
                     <code class="block mb-4">
                        $$W_n = \oint \partial_0 \Theta_n(x^0) \, dx^0$$
                    </code>
                     <p class="mb-2">
                        Spin ($s_n$) is the normalized winding number:
                    </p>
                    <code class="block mb-4">
                        $$s_n = \frac{W_n}{2\pi}$$
                    </code>
                    <p class="mb-2">
                        This predicts a discrete spin spectrum based on integer $W_n$:
                    </p>
                    <table class="min-w-full bg-[#1f2833] text-[#c5c6c7] rounded-md overflow-hidden">
                        <thead>
                            <tr>
                                <th class="py-2 px-4 border-b border-[#2f3b4a] text-left text-[#66fcf1]">Winding Number ($W_n$)</th>
                                <th class="py-2 px-4 border-b border-[#2f3b4a] text-left text-[#66fcf1]">Predicted Spin ($s_n$)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">0</td>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">0</td>
                            </tr>
                             <tr>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">$\pm 1$</td>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">0.5</td>
                            </tr>
                             <tr>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">$\pm 2$</td>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">1</td>
                            </tr>
                             <tr>
                                <td class="py-2 px-4">$\pm 4$</td>
                                <td class="py-2 px-4">2</td>
                            </tr>
                        </tbody>
                    </table>
                     <p class="mt-4 text-sm text-[#c5c6c7]">
                         Parameter-free spin from field geometry.
                     </p>
                </div>
                </div>
        </div>
    </div>
</body>
<script>
const Decimal = window.Decimal;

// Configure Decimal.js to prevent exponential notation for large numbers unless necessary
Decimal.set({ toExpNeg: -100, toExpPos: 100 });

const particleData = {
    'Electron': { n: new Decimal("1.116146374259776000504792200600740088568081211715959874293260467558912066286342598811550851149432149E+37"), massMeV: new Decimal("0.511"), massKg: new Decimal("9.1094024112e-31"), spin: 0.5, charge: "-1" },
    'Muon': { n: new Decimal("2.592697864681657296450146244390652422592537772891046634886736363692579682058059087602050186683604189E+44"), massMeV: new Decimal("105.658"), massKg: new Decimal("1.8835249314336e-28"), spin: 0.5, charge: "-1" },
    'Tau': { n: new Decimal("2.095680986337253170258875675748172910666647047613700720984627636052801619803503286417059292660495776E+48"), massMeV: new Decimal("1776.86"), massKg: new Decimal("3.1675406591712e-27"), spin: 0.5, charge: "-1" },
    'Up Quark': { n: new Decimal("1.088836195890027612641435350014546608150713460429511408040403495603282986892407218405437160237667553E+39"), massMeV: new Decimal("2.16"), massKg: new Decimal("3.8505497472e-30"), spin: 0.5, charge: "+2/3" },
    'Down Quark': { n: new Decimal("1.264009938464596673844966914217987937065316705487175044408268624382571444972162533651758797313978983E+40"), massMeV: new Decimal("4.67"), massKg: new Decimal("8.3250311664e-30"), spin: 0.5, charge: "-1/3" },
    'Strange Quark': { n: new Decimal("1.726633093608591886026315041941475948780201682689921345272257534636237409991027301458637758034128428E+44"), massMeV: new Decimal("93.0"), massKg: new Decimal("1.65787558560e-28"), spin: 0.5, charge: "-1/3" },
    'Charm Quark': { n: new Decimal("7.2704500204949299557400102797668933795023524796826783304614666647047613700720984627636052801619803503286417059292660495776E+47"), massMeV: new Decimal("1275.0"), massKg: new Decimal("2.272893948000e-27"), spin: 0.5, charge: "+2/3" },
    'Bottom Quark': { n: new Decimal("3.21096191571610331850757003649713130046128609586401166643683559161870481286095864011666436835591618704812796308377279745152580586885E+49"), massMeV: new Decimal("4180.0"), massKg: new Decimal("7.451526825600e-27"), spin: 0.5, charge: "-1/3" },
    'Top Quark': { n: new Decimal("4.651419918945756274111528049292917059116238893390426300227887923322275464970993060385669332631062020E+54"), massMeV: new Decimal("172760.0"), massKg: new Decimal("3.07972673299200e-25"), spin: 0.5, charge: "+2/3" },
    'Electron Neutrino': { n: new Decimal("4.785985134579887317477263205775043550151598196481330037114055446129654035793133898715562622692070030E+15"), massMeV: new Decimal("8.3e-8"), massKg: new Decimal("1.4796093936e-37"), spin: 0.5, charge: "0" },
    'Muon Neutrino': { n: new Decimal("1.096272292418038578417998567555555293953541797788583513878935656016903791909266599896029373114823482E+26"), massMeV: new Decimal("0.00017"), massKg: new Decimal("3.030525264e-34"), spin: 0.5, charge: "0" },
    'Tau Neutrino': { n: new Decimal("4.265362646684764673113288026757181623709717578980016381397855225624154285667626703797760605707288949E+31"), massMeV: new Decimal("0.01"), massKg: new Decimal("1.78266192e-32"), spin: 0.5, charge: "0" },
    'Photon': { n: new Decimal("0"), massMeV: new Decimal("0"), massKg: new Decimal("0"), spin: 1, charge: "0" },
    'Gluon': { n: new Decimal("0"), massMeV: new Decimal("0"), massKg: new Decimal("0"), spin: 1, charge: "0" },
    'Graviton': { n: new Decimal("0"), massMeV: new Decimal("0"), massKg: new Decimal("0"), spin: 2, charge: "0" },
    'W Boson': { n: new Decimal("4.036085307766214873433443189812547753999403904296589500223267049268569767308755430179131598933931338E+53"), massMeV: new Decimal("80379.0"), massKg: new Decimal("1.43288582467680e-25"), spin: 1, charge: "±1" },
    'Z Boson': { n: new Decimal("6.039398982388116321671579194641872927161651630537805218977885250419202729193657964270366E+53"), massMeV: new Decimal("91187.6"), massKg: new Decimal("1.62556662096192e-25"), spin: 1, charge: "0" },
    'Higgs Boson': { n: new Decimal("1.658406012128395459983844710359379460541422054894899713401688352608020961902278624762480085545597019E+54"), massMeV: new Decimal("125100.0"), massKg: new Decimal("2.23011006192000e-25"), spin: 0, charge: "0" },
    // Added CNG Prediction 1 data
    'CNG Prediction 1': { n: new Decimal("1"), massMeV: new Decimal("27913.8699999999989813659340143203735351562500000000000000000000"), massKg: new Decimal("0.0000000000000000000000000497609900000000021102310454340774472"), spin: 'See SM Spin / CNG Interpretation', charge: "N/A (Electron-calibrated)" },
    // Added CNG Prediction 2 data
    'CNG Prediction 2': { n: new Decimal("2"), massMeV: new Decimal("692303.4000000000232830643653869628906250000000000000000000000000"), massKg: new Decimal("0.0000000000000000000000012341429999999999761507075425760540424"), spin: 'See SM Spin / CNG Interpretation', charge: "N/A (Electron-calibrated)" }
};

// NOTE: Proton and Neutron are composite particles, their 'n' values and properties here
// are based on the Chronogenesis model's interpretation of their composite modes,
// not fundamental single modes like the leptons and quarks.
const compositeParticleData = {
     'Proton': { n: new Decimal("1.774015855819727177401585581972717740158558197271774015855819727177401585581972717740158558197271774E+40"), massMeV: new Decimal("938.272"), massKg: new Decimal("1.67262192369e-27"), spin: 0.5, charge: "+1" },
     'Neutron': { n: new Decimal("1.7758528914340380702431901388836195890027612641435350014546608150713460429511408040403495603282986892407218405437160237667553E+40"), massMeV: new Decimal("939.565"), massKg: new Decimal("1.67492749804e-27"), spin: 0.5, charge: "0" }
};

// Combine fundamental and composite particle data for rendering buttons and list
// Ensure that the new CNG predictions are included here
const allParticleData = { ...particleData, ...compositeParticleData };


const mevToKg = new Decimal("1.78266192e-30"); // Conversion factor MeV/c^2 to kg

// Fundamental constants (using Decimal.js)
const PLANCK_REDUCED = new Decimal("1.054571817e-34"); // Reduced Planck constant in J*s
const BOLTZMANN_CONSTANT = new Decimal("1.380649e-23"); // Boltzmann constant in J/K (for entropy interpretation)

// Chronogenesis constants (using Decimal.js)
const BETA_REDSHIFT = new Decimal("1.97e-4"); // Beta constant for redshift calculation
const THETA_FIELD = new Decimal("1"); // Theta field value (naturalized units)
const BETA_ENTROPY = new Decimal("1.44e-24"); // Beta constant for entropy calculation (Planck-normalized J/K)
const SHELL_A = new Decimal("1.43"); // Constant 'a' for shell layer calculation
const SHELL_B = new Decimal("3.11"); // Constant 'b' for shell layer calculation
const LN10 = new Decimal('2.302585092994045684017991'); // ln(10) for base-10 logarithm conversion


// Calculate the alpha constant using Electron data
const kappaElectron = new Decimal("6.7060821879436456799748104656833798181752300741342e+24");
const alphaMeV = allParticleData['Electron'].massMeV.div(kappaElectron.sqrt());

// Hardcoded mode indices for CNG predictions (These are now included in particleData)
// const cngPredictionN1 = new Decimal("1.3771423946537758804255e+52");
// const cngPredictionN2 = new Decimal("3.9284999846221127751102e+56");

// Define practical limits for custom input to avoid computational issues
const N_MAX_LIMIT = new Decimal("1e300"); // Example: Limit to avoid excessive computation/memory
const N_MIN_LIMIT = new Decimal("1e-300"); // Example: Limit to avoid issues with log of very small numbers


// Function to calculate the curvature kappa(n)
function curvatureKappa(n) {
    const N = new Decimal(n);
     // Check if n is finite and non-negative before calculating log
    if (!N.isFinite() || N.lt(0)) {
        console.error("Invalid input for curvatureKappa: n must be a finite, non-negative number.");
        return new Decimal(NaN); // Return NaN for invalid input
    }
    // Handle n=0 case explicitly to avoid log(1) issues if any, though ln(1) is 0
    if (N.equals(0)) {
         return new Decimal(0); // Kappa is 0 for n=0 in this formula
    }
    // Ensure n+1 is positive for log
    if (N.plus(1).lte(0)) {
        console.error("Logarithm input (n+1) must be positive.");
        return new Decimal(NaN); // Return NaN for invalid input
    }
    const kappa = N.pow(0.618).times(N.plus(1).ln());
    // Check if kappa is finite after calculation
    if (!kappa.isFinite()) {
         console.error("Curvature calculation resulted in non-finite value.");
         return new Decimal(NaN);
    }
    return kappa;
}

// Function to calculate predicted mass in MeV
function massMeV(n) {
    const kappa = curvatureKappa(n);
    if (kappa.isNaN() || !kappa.isFinite() || kappa.lt(0)) { // Check for NaN, Infinity, or negative kappa
        console.error("Invalid kappa for massMeV calculation.");
        return new Decimal(NaN);
    }
    const mass = alphaMeV.times(kappa.sqrt());
     // Check if mass is finite after calculation
    if (!mass.isFinite()) {
         console.error("Mass calculation resulted in non-finite value.");
         return new Decimal(NaN);
    }
    return mass;
}

// Function to calculate predicted mass in Kg
function massKg(n) {
    const kappa = curvatureKappa(n);
     if (kappa.isNaN() || !kappa.isFinite() || kappa.lt(0)) { // Check for NaN, Infinity, or negative kappa
        console.error("Invalid kappa for massKg calculation.");
        return new Decimal(NaN);
    }
    const mass = alphaMeV.times(kappa.sqrt()).times(mevToKg);
     // Check if mass is finite after calculation
    if (!mass.isFinite()) {
         console.error("Mass calculation resulted in non-finite value.");
         return new Decimal(NaN);
    }
    return mass;
}

// Function to calculate Redshift Origin (z)
function calculateRedshift(kappa) {
     if (kappa.isNaN() || !kappa.isFinite() || kappa.lt(0)) {
         return new Decimal(NaN); // Invalid kappa
     }
     // z_n = beta * (kappa_n)^(1/3)
     const redshift = BETA_REDSHIFT.times(kappa.pow(1/3));
     return redshift.isFinite() ? redshift : new Decimal(NaN);
}

// Function to calculate Quantum Decoherence Time (tau_D) in femtoseconds
function calculateDecoherenceTime(n) {
     const kappa = curvatureKappa(n);
     // Add check for kappa being zero or invalid before division
     if (kappa.isNaN() || !kappa.isFinite() || kappa.lte(0)) { // kappa must be positive for division
         if (kappa.isZero()) {
             console.warn("Decoherence time calculation resulted in division by zero (kappa = 0).");
         } else {
              console.error("Invalid or non-positive kappa for decoherence time calculation.");
         }
         return new Decimal(NaN); // Return NaN for invalid or zero kappa
     }
     // tau_D = hbar / (Delta_kappa * Theta)
     // Using simplified Delta_kappa = kappa_n and Theta = 1
     const tau_D_seconds = PLANCK_REDUCED.div(kappa.times(THETA_FIELD));
     const tau_D_fs = tau_D_seconds.times("1e15"); // Convert seconds to femtoseconds
     return tau_D_fs.isFinite() ? tau_D_fs : new Decimal(NaN);
}

// Function to calculate Entropy Contribution (S) in J/K
function calculateEntropy(kappa) {
     // Add safety check for kappa
     if (kappa.isNaN() || !kappa.isFinite() || kappa.lt(0)) {
         console.error("Invalid kappa for entropy calculation.");
         return new Decimal(NaN); // Invalid kappa
     }
     // S_n = beta * kappa_n
     const entropy = BETA_ENTROPY.times(kappa);
     return entropy.isFinite() ? entropy : new Decimal(NaN);
}

// Function to calculate Shell Layer Position (k)
function calculateShellLayer(n) {
     if (!n.isFinite() || !n.gt(0)) { // n must be finite and positive for log10
         if (n.isZero()) {
              console.warn("Shell layer calculation requires n > 0. Received n = 0.");
         } else {
              console.error("Invalid or non-positive n for shell layer calculation.");
         }
         return new Decimal(NaN); // Invalid or non-positive n
     }
     // k = log10(n) / a - b
     // FIX: Use base-10 logarithm by dividing natural log by ln(10)
     const log10_n = n.log().div(LN10);
     const shellLayer = log10_n.div(SHELL_A).minus(SHELL_B);
     return shellLayer.isFinite() ? shellLayer : new Decimal(NaN);
}

// Function to predict spin based on the topological winding number concept
// This is a simplified representation based on the provided mapping, not a live calculation
function predictSpin(n) {
    // This mapping is based on the *expected* winding number for modes corresponding
    // to known particles, according to the Chronogenesis model's interpretation.
    // It does NOT perform the actual PDE solution and path integral.

    // For n=0 modes (Photon, Gluon, Graviton), the winding number is 2, corresponding to spin 1 or 2
    if (n.equals(0)) {
        // Distinguish between spin 1 and spin 2 for n=0 based on particle type (hardcoded)
        // This is a simplification as the model predicts the winding number, not the specific particle type
        // We'll return a placeholder indicating it's an n=0 boson
        return 'Boson (n=0)'; // Represents winding number +/-2 or +/-4
    }

    // For large n modes corresponding to fermions (leptons, quarks, proton, neutron)
    // the winding number is expected to be +/-1, corresponding to spin 0.5
    // For large n modes corresponding to massive bosons (W, Z, Higgs)
    // the winding number is expected to be 0, corresponding to spin 0 or 1

    // Since we don't calculate the winding number directly, we'll infer the predicted spin
    // based on whether n > 0. This is a necessary simplification for this calculator.
    // A non-zero n is generally associated with non-zero winding numbers.
    // Based on the provided mapping:
    // Winding Number +/-1 -> Spin 0.5
    // Winding Number 0 -> Spin 0
    // Winding Number +/-2 -> Spin 1
    // Winding Number +/-4 -> Spin 2

    // For simplicity in this calculator, we'll use a lookup based on the particle's
    // hardcoded spin, assuming it corresponds to the expected winding number for that class.
    // This is a practical workaround until the full winding number calculation is feasible.

    // We'll return a string indicating the predicted spin based on the *expected* winding number
    // for the class of particle represented by this n.
    // This is NOT a direct calculation from the provided formula in this JS code.
    // It's a lookup based on the known particle's type and the winding number -> spin table.

     // This is a simplified lookup based on particle type/expected spin from data
     // This does NOT implement the integral calculation.
     // A more accurate simulation would involve mapping n ranges to expected winding numbers.
     // For now, we'll use the particle's hardcoded spin as a proxy for the *expected* topological spin.

     // We cannot reliably predict the winding number or spin for arbitrary custom N
     // without implementing the full field theory calculation.
     // For custom N, we'll return 'Unknown (Calculation Complex)'

     return 'See SM Spin / CNG Interpretation'; // Indicate spin is based on the model's interpretation and SM data
}


// Function to calculate percentage alignment between predicted and observed values
// This function will still use standard numbers for calculation as percentages are approximations
function calculateAlignment(predicted, observed) {
    // Ensure inputs are standard numbers for calculation and are finite
    const predNum = parseFloat(predicted.toString());
    const obsNum = parseFloat(observed.toString());

    if (!isFinite(predNum) || !isFinite(obsNum)) {
        return 'N/A';
    }

    // Handle cases where observed is zero to avoid division by zero
    if (obsNum === 0 && predNum === 0) {
        return '100.000000%';
    }
     if (obsNum === 0) { // Predicted is non-zero, observed is zero
         return 'N/A';
     }

    const avg = (Math.abs(predNum) + Math.abs(obsNum)) / 2;
    const diff = Math.abs(predNum - obsNum);
    // Avoid division by zero if avg is zero
    return (avg === 0) ? 'N/A' : (100 * (1 - diff / avg)).toFixed(6) + '%';
}

// Function to get mass and other data for a given mode index n
function getParticleData(n, particleName = null) { // Added particleName parameter
    const predictedMeV = massMeV(n);
    const predictedKg = massKg(n);
    const curvature = curvatureKappa(n);
    const redshift = calculateRedshift(curvature);
    const decoherenceTime = calculateDecoherenceTime(n); // Decoherence time depends on n
    const entropy = calculateEntropy(curvature);
    const shellLayer = calculateShellLayer(n);

    // Predict spin using the new conceptual function
    const predictedSpin = predictSpin(n);


    // Handle potential NaN or Infinity results from calculations and return appropriate strings
    // Apply toExponential(6) formatting here for consistency
    const predictedMeVDisplay = predictedMeV.isNaN() || !predictedMeV.isFinite() ? 'N/A' : predictedMeV.toExponential(6);
    const predictedKgDisplay = predictedKg.isNaN() || !predictedKg.isFinite() ? 'N/A' : predictedKg.toExponential(6);
    const curvatureDisplay = curvature.isNaN() || !curvature.isFinite() ? 'N/A' : curvature.toExponential(6);
    const redshiftDisplay = redshift.isNaN() || !redshift.isFinite() ? 'N/A' : redshift.toExponential(6);
    const decoherenceTimeDisplay = decoherenceTime.isNaN() || !decoherenceTime.isFinite() ? 'N/A' : decoherenceTime.toExponential(6);
    const entropyDisplay = entropy.isNaN() || !entropy.isFinite() ? 'N/A' : entropy.toExponential(6);
    const shellLayerDisplay = shellLayer.isNaN() || !shellLayer.isFinite() ? 'N/A' : shellLayer.toFixed(6); // Keep shell layer decimal format
    const predictedSpinDisplay = predictedSpin; // Use the string from the new predictSpin


     // Determine Shell Layer display - Keep fixed or decimal based on integer check
     let shellLayerFormatted = 'N/A';
     let shellMatchNote = '';
     if (!shellLayer.isNaN() && shellLayer.isFinite()) {
         const integerPart = shellLayer.floor();
         const fractionalPart = shellLayer.minus(integerPart).abs();
         const tolerance = new Decimal("1e-6"); // Tolerance for integer check

         if (fractionalPart.lt(tolerance) || fractionalPart.gt(new Decimal(1).minus(tolerance))) {
             // It's close to an integer
             shellLayerFormatted = shellLayer.toFixed(0); // Display as integer
             shellMatchNote = ' <strong class="text-[#00ff88]">Strong Cosmic Shell Match ✔</strong>';
         } else {
             shellLayerFormatted = shellLayer.toFixed(6); // Display with decimals
         }
     }


    return {
        predictedMeV: predictedMeVDisplay,
        predictedKg: predictedKgDisplay,
        curvature: curvatureDisplay,
        redshift: redshiftDisplay,
        decoherenceTime: decoherenceTimeDisplay,
        entropy: entropyDisplay,
        shellLayer: shellLayerFormatted, // Use formatted shell layer
        shellMatchNote: shellMatchNote,
        predictedSpin: predictedSpinDisplay
    };
}

// Function to display particle data in the screen (triggered by left buttons)
function showParticle(name) {
    try { // Added try-catch for error isolation
        const p = allParticleData[name]; // Use allParticleData to include composites
        const { predictedMeV, predictedKg, curvature, redshift, decoherenceTime, entropy, shellLayer, shellMatchNote, predictedSpin } = getParticleData(p.n, name); // Pass name

        // Calculate alignment using Decimal objects and then convert to number for calculation
        const alignmentMeV = p.massMeV.gt(0) ? calculateAlignment(predictedMeV, p.massMeV.toExponential(6)) : 'N/A'; // Format measured for alignment check
        const alignmentKg = p.massKg.gt(0) ? calculateAlignment(predictedKg, p.massKg.toExponential(6)) : 'N/A'; // Format measured for alignment check

        // Display a fixed placeholder for the mode index in the main display
        const displayN = "[See list on right]"; // Reverted to placeholder

        // Check for spin mismatch and add warning - Now comparing predicted string to SM value
        let spinWarning = '';
        // Only show warning if predictedSpin is not the generic 'See SM Spin...' placeholder
        if (predictedSpin !== 'See SM Spin / CNG Interpretation' && p.spin !== undefined) {
             const predictedSpinFloat = parseFloat(predictedSpin);
             if (!isNaN(predictedSpinFloat) && predictedSpinFloat !== p.spin) {
                 spinWarning = `<span class="warning">Spin Mismatch! Predicted (CNG Winding): ${predictedSpin}, Expected (SM): ${p.spin}</span>`;
                 console.warn(`Spin mismatch for ${name}: Predicted (CNG Winding) ${predictedSpin}, Expected (SM) ${p.spin}`);
             } else if (isNaN(predictedSpinFloat) && predictedSpin !== p.spin.toString()) {
                  // Handle cases where predictedSpin is a string like 'Boson (n=0)'
                  // We can't directly compare 'Boson (n=0)' to a number like 1 or 2,
                  // so we'll rely on the user seeing the difference or add specific checks if needed.
                  // For now, the string predictedSpin will be displayed.
             }
        }


        // Determine highlighting and error messages for calculated properties
        const isNZero = p.n.equals(0);

        const predictedMeVHTML = isNZero && (predictedMeV === '0.000000e+0' || predictedMeV === 'N/A') ? `<span class="highlight-green">${predictedMeV}</span>` : predictedMeV;
        const predictedKgHTML = isNZero && (predictedKg === '0.000000e+0' || predictedKg === 'N/A') ? `<span class="highlight-green">${predictedKg}</span>` : predictedKg;
        const curvatureHTML = isNZero && (curvature === '0.000000e+0' || curvature === 'N/A') ? `<span class="highlight-green">${curvature}</span>` : curvature;
        const redshiftHTML = isNZero && (redshift === '0.000000e+0' || redshift === 'N/A') ? `<span class="highlight-green">${redshift}</span>` : redshift;
        const decoherenceTimeHTML = isNZero && (decoherenceTime === '0.000000e+0' || decoherenceTime === 'N/A') ? `<span class="highlight-green">${decoherenceTime}</span>` : decoherenceTime;
        const entropyHTML = isNZero && (entropy === '0.000000e+0' || entropy === 'N/A') ? `<span class="highlight-green">${entropy}</span>` : entropy;
        const shellLayerHTML = isNZero && (shellLayer === '0' || shellLayer === 'N/A') ? `<span class="highlight-green">${shellLayer}</span>` : shellLayer;
        // Highlight predicted spin if it matches SM spin (requires parsing predictedSpin string)
        const predictedSpinMatchSM = predictedSpin !== 'N/A' && p.spin !== undefined && parseFloat(predictedSpin) === p.spin;
        const predictedSpinHTMLDisplay = predictedSpinMatchSM ? `<span class="highlight-green">${predictedSpin}</span>` : predictedSpin;


        // Add on-screen error messages for N/A values only if n > 0
        const predictedMeVError = predictedMeV === 'N/A' && !isNZero ? `<span class="error-message"> (Error)</span>` : '';
        const predictedKgError = predictedKg === 'N/A' && !isNZero ? `<span class="error-message"> (Error)</span>` : '';
        const curvatureError = curvature === 'N/A' && !isNZero ? `<span class="error-message"> (Error)</span>` : '';
        const redshiftError = redshift === 'N/A' && !isNZero ? `<span class="error-message"> (Error)</span>` : '';
        const decoherenceTimeError = decoherenceTime === 'N/A' && !isNZero ? `<span class="error-message"> (Error)</span>` : '';
        const entropyError = entropy === 'N/A' && !isNZero ? `<span class="error-message"> (Error)</span>` : '';
        const shellLayerError = shellLayer === 'N/A' && !isNZero ? `<span class="error-message"> (Error)</span>` : '';
        const predictedSpinError = predictedSpin === 'N/A' && !isNZero ? `<span class="error-message"> (Error)</span>` : '';


        // Build the display HTML
        let displayHTML = `
            <strong>${name}</strong><br>
            Mode Index (n): ${displayN}<br>
            Measured MeV: ${p.massMeV.toExponential(6)} MeV<br> Predicted Mass (MeV): ${predictedMeVHTML} MeV${predictedMeVError}<br>
            Measured Mass (CODATA): ${p.massKg.toExponential(6)} kg<br> Predicted Mass (kg): ${predictedKgHTML} kg${predictedKgError}<br>
            Time-Curvature Mode κ<sub>n</sub> (unitless): ${curvatureHTML}${curvatureError}<br>
            Redshift Origin (z): ${redshiftHTML}${redshiftError}<br>
            Quantum Decoherence Time (τ<sub>D</sub>) (fs): ${decoherenceTimeHTML}${decoherenceTimeError}<br>
            Entropy Contribution (S<sub>n</sub>) (J/K): ${entropyHTML}${entropyError}<br>
            Resonance Shell Layer k: ${shellLayerHTML}${shellLayerError}${shellMatchNote}<br>
            Standard Model Spin: ${p.spin}<br> Predicted Spin (CNG Winding): ${predictedSpinHTMLDisplay} ${spinWarning}${predictedSpinError}<br> Charge (Placeholder/Manual Entry): ${p.charge}<br>
        `;

        // Highlight alignment if 100%
        const alignmentMeVHTML = alignmentMeV === '100.000000%' ? `<span class="highlight-green">${alignmentMeV}</span>` : alignmentMeV;
        const alignmentKgHTML = alignmentKg === '100.000000%' ? `<span class="highlight-green">${alignmentKg}</span>` : alignmentKg;

         displayHTML += `Alignment (MeV): ${alignmentMeVHTML}<br>
            Alignment (kg): ${alignmentKgHTML}<br>`;


        // Check and display if the mode is in a resonant stability valley
        if (isResonantValley(p.n)) {
            displayHTML += `<br><strong class="text-[#66fcf1]">Resonant Stability Valley ✔ (Expected longer lifetime/stable decay)</strong>`;
        }

        document.getElementById("display").innerHTML = displayHTML;


        // Log any NaN or Infinity values for this particle if n > 0
        if (!isNZero && (predictedMeV === 'N/A' || predictedKg === 'N/A' || curvature === 'N/A' || redshift === 'N/A' || decoherenceTime === 'N/A' || entropy === 'N/A' || shellLayer === 'N/A' || predictedSpin === 'N/A')) {
             console.error(`Calculation error for ${name} (n > 0). Check individual property values.`);
        }


    } catch (error) {
        console.error("Error displaying particle data for", name, ":", error);
        document.getElementById("display").innerHTML = `<strong class="text-red-500">Error displaying data for ${name}. Please check console for details.</strong>`;
    }
}

// Function to display CNG Prediction data in the screen
function showCngPrediction(name) { // Modified to accept name directly
    try { // Added try-catch for error isolation
        const p = allParticleData[name]; // Get data using the name
        const { predictedMeV, predictedKg, curvature, redshift, decoherenceTime, entropy, shellLayer, shellMatchNote, predictedSpin } = getParticleData(p.n, name); // Pass name

         // Display a fixed placeholder for the mode index in the main display
        const displayN = "[See list on right]"; // Reverted to placeholder

        let spinDescription = '';
         // Use the predictedSpin string directly
         if (predictedSpin.includes('0.5')) {
            spinDescription = '— matter';
        } else if (predictedSpin.includes('1')) {
            spinDescription = '— force carrier';
        } else if (predictedSpin.includes('Boson (n=0)')) {
             spinDescription = '— boson (n=0)';
        }


        let valleyStatus = '';
        // Only check for resonant valley if predicted values are finite
        if (isResonantValley(p.n) && isFinite(parseFloat(predictedMeV)) && isFinite(parseFloat(predictedKg))) {
            valleyStatus = `<br><strong class="text-[#66fcf1]">Resonant Stability Valley ✔ (Expected longer lifetime/stable decay)</strong>`;
        }

        // Determine highlighting and error messages for calculated properties
        const isNZero = p.n.equals(0); // Should not happen for CNG predictions with hardcoded large N, but for safety

        const predictedMeVHTML = predictedMeV; // No green highlight for predictions unless they match something known, which isn't implemented
        const predictedKgHTML = predictedKg;
        const curvatureHTML = curvature;
        const redshiftHTML = redshift;
        const decoherenceTimeHTML = decoherenceTime;
        const entropyHTML = entropy;
        const shellLayerHTML = shellLayer;
        const predictedSpinHTML = predictedSpin; // No green highlight for predictions unless they match something known

        // Add on-screen error messages for N/A values
        const predictedMeVError = predictedMeV === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const predictedKgError = predictedKg === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const curvatureError = curvature === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const redshiftError = redshift === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const decoherenceTimeError = decoherenceTime === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const entropyError = entropy === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const shellLayerError = shellLayer === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const predictedSpinError = predictedSpin === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';


         // Build the display HTML
        let displayHTML = `
            <strong>${name}</strong><br>
            Mode Index (n): ${displayN}<br> Predicted Mass (MeV): ${predictedMeVHTML} MeV${predictedMeVError}<br>
            Predicted Mass (kg): ${predictedKgHTML} kg${predictedKgError}<br>
            Time-Curvature Mode κ<sub>n</sub> (unitless): ${curvatureHTML}${curvatureError}<br>
            Redshift Origin (z): ${redshiftHTML}${redshiftError}<br>
            Quantum Decoherence Time (τ<sub>D</sub>) (fs): ${decoherenceTimeHTML}${decoherenceTimeError}<br>
            Entropy Contribution (S<sub>n</sub>) (J/K): ${entropyHTML}${entropyError}<br>
            Resonance Shell Layer k: ${shellLayerHTML}${shellLayerError}${shellMatchNote}<br>
            Predicted Spin (CNG Winding): ${predictedSpinHTML} ${spinDescription}${predictedSpinError}<br> Charge (Placeholder/Manual Entry): ${p.charge} ${valleyStatus}
        `;

        document.getElementById("display").innerHTML = displayHTML;


         // Log any NaN or Infinity values for this prediction
        if (predictedMeV === 'N/A' || predictedKg === 'N/A' || curvature === 'N/A' || redshift === 'N/A' || decoherenceTime === 'N/A' || entropy === 'N/A' || shellLayer === 'N/A' || predictedSpin === 'N/A') {
             console.error(`Calculation error for ${name}. Check individual property values.`);
        }

    } catch (error) {
        console.error("Error displaying CNG Prediction", name, "data:", error);
        document.getElementById("display").innerHTML = `<strong class="text-red-500">Error displaying data for ${name}. Please check console for details.</strong>`;
    }
}


// Function to handle custom mode index input (triggered by left button)
function customN() {
    try { // Added try-catch for error isolation
        const nInput = prompt("Enter mode index n:");
        if (nInput === null) return; // User cancelled prompt

        let n;
        try {
            n = new Decimal(nInput);
        } catch (e) {
            // Handle Decimal.js parsing errors
            alert("Invalid input. Please enter a valid number.");
            console.error("Decimal.js parsing error for custom input:", e);
            return;
        }

        // Add more robust validation for custom input
        if (!n.isFinite() || n.lt(0)) { // Check for non-finite or negative
            alert("Invalid input. Please enter a non-negative finite number.");
            console.error("Invalid custom input: not finite or negative.", n);
            return;
        }

        // Add checks for extremely large/small values that might cause issues
        if (n.abs().gt(N_MAX_LIMIT)) {
             alert(`Input too large. Please enter a value less than or equal to ${N_MAX_LIMIT.toExponential()}.`);
             console.error("Invalid custom input: exceeds max limit.", n);
             return;
        }
         if (n.abs().lt(N_MIN_LIMIT) && !n.equals(0)) {
             alert(`Input too small. Please enter a value greater than or equal to ${N_MIN_LIMIT.toExponential()} or exactly 0.`);
             console.error("Invalid custom input: below min limit (and not zero).", n);
             return;
         }


        const { predictedMeV, predictedKg, curvature, redshift, decoherenceTime, entropy, shellLayer, shellMatchNote, predictedSpin } = getParticleData(n);

         // Display a fixed placeholder for the mode index in the main display
        const displayN = "[See list on right]"; // Reverted to placeholder

        let spinDescription = '';
         // Use the predictedSpin string directly
         if (predictedSpin.includes('0.5')) {
            spinDescription = '— matter-like'; // Use "matter-like" for custom 0.5
        } else if (predictedSpin.includes('1')) {
            spinDescription = '— force carrier-like'; // Use "force carrier-like" for custom 1
        } else if (predictedSpin.includes('Boson (n=0)')) {
             spinDescription = '— boson (n=0)';
        }


        let valleyStatus = '';
         // Only check for resonant valley if predicted values are finite
        if (isResonantValley(n) && isFinite(parseFloat(predictedMeV)) && isFinite(parseFloat(predictedKg))) {
            valleyStatus = `<br><strong class="text-[#66fcf1]">Resonant Stability Valley ✔ (Expected longer lifetime/stable decay)</strong>`;
        }

        // Determine highlighting and error messages for calculated properties
        const isNZero = n.equals(0);

        const predictedMeVHTML = isNZero && (predictedMeV === '0.000000e+0' || predictedMeV === 'N/A') ? `<span class="highlight-green">${predictedMeV}</span>` : predictedMeV;
        const predictedKgHTML = isNZero && (predictedKg === '0.000000e+0' || predictedKg === 'N/A') ? `<span class="highlight-green">${predictedKg}</span>` : predictedKg;
        const curvatureHTML = isNZero && (curvature === '0.000000e+0' || curvature === 'N/A') ? `<span class="highlight-green">${curvature}</span>` : curvature;
        const redshiftHTML = isNZero && (redshift === '0.000000e+0' || redshift === 'N/A') ? `<span class="highlight-green">${redshift}</span>` : redshift;
        const decoherenceTimeHTML = isNZero && (decoherenceTime === '0.000000e+0' || decoherenceTime === 'N/A') ? `<span class="highlight-green">${decoherenceTime}</span>` : decoherenceTime;
        const entropyHTML = isNZero && (entropy === '0.000000e+0' || entropy === 'N/A') ? `<span class="highlight-green">${entropy}</span>` : entropy;
        const shellLayerHTML = isNZero && (shellLayer === '0' || shellLayer === 'N/A') ? `<span class="highlight-green">${shellLayer}</span>` : shellLayer;
        // Highlight predicted spin for custom input if it's 0.5 or 1 (based on the new mapping)
        const predictedSpinHTMLDisplay = (predictedSpin.includes('0.5') || predictedSpin.includes('1')) ? `<span class="highlight-green">${predictedSpin}</span>` : predictedSpin;


        // Add on-screen error messages for N/A values only if n > 0 or if n=0 but the value wasn't 0/N/A
        const predictedMeVError = predictedMeV === 'N/A' && !(isNZero && (predictedMeV === '0.000000e+0' || predictedMeV === 'N/A')) ? `<span class="error-message"> (Error)</span>` : '';
        const predictedKgError = predictedKg === 'N/A' && !(isNZero && (predictedKg === '0.000000e+0' || predictedKg === 'N/A')) ? `<span class="error-message"> (Error)</span>` : '';
        const curvatureError = curvature === 'N/A' && !(isNZero && (curvature === '0.000000e+0' || curvature === 'N/A')) ? `<span class="error-message"> (Error)</span>` : '';
        const redshiftError = redshift === 'N/A' && !(isNZero && (redshift === '0.000000e+0' || redshift === 'N/A')) ? `<span class="error-message"> (Error)</span>` : '';
        const decoherenceTimeError = decoherenceTime === 'N/A' && !(isNZero && (decoherenceTime === '0.000000e+0' || decoherenceTime === 'N/A')) ? `<span class="error-message"> (Error)</span>` : '';
        const entropyError = entropy === 'N/A' && !(isNZero && (entropy === '0.000000e+0' || entropy === 'N/A')) ? `<span class="error-message"> (Error)</span>` : '';
        const shellLayerError = shellLayer === 'N/A' && !(isNZero && (shellLayer === '0' || shellLayer === 'N/A')) ? `<span class="error-message"> (Error)</span>` : '';
        const predictedSpinError = predictedSpin === 'N/A' ? `<span class="error-message"> (Error)</span>` : ''; // Spin N/A is always an error


        // Build the display HTML
        let displayHTML = `
            <strong>Custom Mode</strong><br>
            n = ${displayN}<br> Predicted Mass (MeV): ${predictedMeVHTML} MeV${predictedMeVError}<br>
            Predicted Mass (kg): ${predictedKgHTML} kg${predictedKgError}<br>
            Time-Curvature Mode κ<sub>n</sub> (unitless): ${curvatureHTML}${curvatureError}<br>
            Redshift Origin (z): ${redshiftHTML}${redshiftError}<br>
            Quantum Decoherence Time (τ<sub>D</sub>) (fs): ${decoherenceTimeHTML}${decoherenceTimeError}<br>
            Entropy Contribution (S<sub>n</sub>) (J/K): ${entropyHTML}${entropyError}<br>
            Resonance Shell Layer k: ${shellLayerHTML}${shellLayerError}${shellMatchNote}<br>
            Predicted Spin (CNG Winding): ${predictedSpinHTMLDisplay} ${spinDescription}${predictedSpinError}<br> Charge (Placeholder/Manual Entry): N/A (Electron-calibrated) ${valleyStatus} `;

        document.getElementById("display").innerHTML = displayHTML;


         // Log any NaN or Infinity values for this custom mode
        if (predictedMeV === 'N/A' || predictedKg === 'N/A' || curvature === 'N/A' || redshift === 'N/A' || decoherenceTime === 'N/A' || entropy === 'N/A' || shellLayer === 'N/A' || predictedSpin === 'N/A') {
            console.error(`Calculation error for custom mode (n=${nInput}). Check individual property values.`);
        }

    } catch (error) {
        console.error("Error calculating custom mode data:", error);
        document.getElementById("display").innerHTML = `<strong class="text-red-500">Error calculating custom mode data. Please check console for details.</strong>`;
    }
}

// Function to clear the display screen (triggered by left button)
function clearDisplay() {
    document.getElementById("display").innerText = "Select a particle or prediction to view data.";
}

// Function to toggle the visibility of the formula display
function showFormula() {
    const formulaDisplay = document.getElementById("formulaDisplay");
    if (formulaDisplay) {
        formulaDisplay.classList.toggle('hidden'); // Use Tailwind's hidden class
        // Trigger MathJax typesetting when the formula display becomes visible
        if (!formulaDisplay.classList.contains('hidden')) {
            MathJax.typesetPromise([formulaDisplay]).catch((err) => console.error('MathJax typesetting failed', err));
        }
    }
}

// Function to render the particle buttons and CNG prediction buttons in the left section
function renderButtons() {
    try {
        const grid = document.getElementById("buttonGrid");
        if (!grid) {
            console.error("Button grid element not found!");
            return; // Cannot render buttons if the grid doesn't exist
        }
        grid.innerHTML = ''; // Clear existing buttons

        console.log("Starting to render particle buttons..."); // Added log

        // Render standard particle buttons (including composites)
        Object.keys(allParticleData).forEach(p => {
            try { // Added inner try-catch for each particle button
                console.log(`Rendering button for: ${p}`); // Added log for particle being processed
                const btn = document.createElement("button");
                btn.textContent = p;
                // Add Tailwind classes for styling
                btn.classList.add('p-3', 'rounded-lg', 'font-bold', 'bg-[#c5c6c7]', 'text-[#1f2833]', 'hover:bg-[#66fcf1]', 'transition', 'duration-200');
                // Wrap the onclick handler in a try-catch
                btn.onclick = () => {
                    try {
                        // Determine if it's a standard particle or a CNG prediction
                        if (p.startsWith('CNG Prediction')) {
                             showCngPrediction(p); // Call showCngPrediction for predictions
                        } else {
                             showParticle(p); // Call showParticle for standard particles
                        }
                    } catch (error) {
                        console.error("Error handling click for button", p, ":", error);
                        document.getElementById("display").innerHTML = `<strong class="text-red-500">Error displaying data for ${p}. Please check console for details.</strong>`;
                    }
                };
                grid.appendChild(btn);
                console.log(`Successfully rendered button for: ${p}`); // Added success log
            } catch (innerError) {
                console.error(`Error rendering button for particle ${p}:`, innerError); // Log specific particle error
                 // Optionally, add a placeholder or skip this button
                 const errorDiv = document.createElement("div");
                 errorDiv.textContent = `Error loading ${p}`;
                 errorDiv.style.color = 'red';
                 grid.appendChild(errorDiv);
            }
        });

        console.log("Finished rendering buttons."); // Added log

    } catch (error) {
        console.error("Error rendering buttons:", error);
        // If button rendering itself fails, display a general error
         const grid = document.getElementById("buttonGrid");
         if (grid) {
              grid.innerHTML = `<strong class="text-red-500">Error loading calculator buttons. Please check console for details.</strong>`;
         } else {
              console.error("Failed to find button grid to display error message.");
         }
    }
}

// Function to render the clickable mode indices list in the right section
function renderModeIndicesList() {
    try {
        const modeIndicesListContainer = document.getElementById("modeIndicesListContainer");
        if (!modeIndicesListContainer) return;

        // Clear existing content except the strong tag title
        const titleTag = modeIndicesListContainer.querySelector('strong');
        modeIndicesListContainer.innerHTML = '';
        if (titleTag) {
            modeIndicesListContainer.appendChild(titleTag);
        } else {
             // If title wasn't found, add it back
             const strongTag = document.createElement('strong');
             strongTag.classList.add('text-[#66fcf1]', 'text-base', 'block', 'mb-2');
             strongTag.textContent = 'Refined Mode Indices (n):';
             modeIndicesListContainer.appendChild(strongTag);
        }

        // Use allParticleData to render the full list
        Object.keys(allParticleData).forEach(pName => {
            const p = allParticleData[pName];

            // Create a container for each particle item
            const itemContainer = document.createElement("div");
            itemContainer.classList.add('mode-index-item-container');

            // Create the clickable particle name element
            const nameDiv = document.createElement("div");
            nameDiv.classList.add('mode-index-item'); // Add class for styling and targeting
            nameDiv.textContent = pName; // Display particle name
            nameDiv.dataset.particleName = pName; // Store particle name for click handling

            // Create the hidden div for displaying the full index
            const fullIndexDiv = document.createElement("div");
            fullIndexDiv.classList.add('full-index-display'); // Add class for styling and targeting

            // Append name and full index div to the item container
            itemContainer.appendChild(nameDiv);
            itemContainer.appendChild(fullIndexDiv);

            // Append the item container to the main list container
            modeIndicesListContainer.appendChild(itemContainer);
        });

        // Add click event listener to the main mode indices list container
        modeIndicesListContainer.addEventListener('click', function(event) {
            try { // Added try-catch for error isolation
                const target = event.target;
                // Check if the clicked element is a particle name item
                if (target && target.classList.contains('mode-index-item')) {
                    const particleName = target.dataset.particleName;
                    if (particleName && allParticleData[particleName]) { // Use allParticleData here
                        displayFullModeIndex(target.closest('.mode-index-item-container'), particleName); // Pass the container and name
                    }
                } else {
                    // If click is not on an item, hide all full displays
                    hideAllFullModeIndices();
                }
            } catch (error) {
                console.error("Error in modeIndicesListContainer click handler:", error);
                // No specific display update for this error, as it's in the list interaction
            }
        });
    } catch (error) {
        console.error("Error rendering mode indices list:", error);
         // If list rendering itself fails, display a general error
         const modeIndicesListContainer = document.getElementById("modeIndicesListContainer");
         if (modeIndicesListContainer) {
              modeIndicesListContainer.innerHTML = `<strong class="text-red-500">Error loading mode indices list. Please check console for details.</strong>`;
         }
    }
}

// Function to display the full mode index for a selected particle, under its name
function displayFullModeIndex(itemContainer, particleName) {
    try { // Added try-catch for error isolation
        const fullDisplayElement = itemContainer.querySelector('.full-index-display');
        const particle = allParticleData[particleName]; // Use allParticleData here

        if (fullDisplayElement && particle) {
            // Hide any currently displayed full indices first
            hideAllFullModeIndices();

            // Display the full, unrounded mode index
            fullDisplayElement.innerHTML = `<strong>Mode Index (n):</strong> ${particle.n.toString()}`;
            fullDisplayElement.style.display = 'block'; // Show the element
        }
    } catch (error) {
         console.error("Error displaying full mode index for", particleName, ":", error);
         // No specific display update for this error, as it's in the list interaction
    }
}

// Function to hide all currently displayed full mode indices
function hideAllFullModeIndices() {
    const allFullDisplays = document.querySelectorAll('.full-index-display');
    allFullDisplays.forEach(el => {
        el.style.display = 'none';
        el.innerHTML = ''; // Clear content when hidden
    });
}


// Function to check if a mode index is in a resonant stability valley (based on second derivative of mass)
function isResonantValley(n) {
    // Use a relative delta based on n for better accuracy with large numbers
    // Ensure n is a positive finite number before calculating delta
     if (!n.isFinite() || n.lt(0)) {
        return false; // Cannot calculate derivative for non-finite or negative n
    }
    const delta = n.times("1e-6");


    // Ensure n +/- delta are positive for curvatureKappa
    if (n.minus(delta).lte(0) || n.plus(delta).lte(0)) {
        return false; // Cannot calculate derivative if n is too small
    }

    const m1 = massMeV(n.minus(delta));
    const m2 = massMeV(n);
    const m3 = massMeV(n.plus(delta));

    // Check for NaN or Infinity results from massMeV
    if (m1.isNaN() || !m1.isFinite() || m2.isNaN() || !m2.isFinite() || m3.isNaN() || !m3.isFinite()) {
        return false;
    }

    // Approximate the second derivative using Decimal objects
    const d2 = (m1.minus(m2.times(2)).plus(m3)).div(delta.times(delta));

    // Define a tolerance for considering it a "valley" (where the second derivative is close to zero)
    // The specific tolerance might need tuning based on the function's behavior
    const valleyTolerance = new Decimal("1e-3"); // Example tolerance - adjust as needed

    // A valley corresponds to a local local minimum or inflection point where the second derivative is close to zero.
    // For a "stability valley", we might also expect the first derivative to be close to zero (local minimum).
    // Let's focus on the second derivative being close to zero for now.
     return d2.abs().lt(valleyTolerance);
}


// Initial rendering of buttons and mode indices list when the page loads
try {
    renderButtons();
    renderModeIndicesList();
} catch (error) {
    console.error("Error during initial rendering:", error);
}
</script>
</html>
