<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronogenesis Mass Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/decimal.js@10.4.3/decimal.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #display, .formula, .mode-indices, .full-index-display {
            font-family: 'JetBrains Mono', monospace;
        }
        /* Ensure the image scales correctly */
        .responsive-img {
            max-width: 100%;
            height: auto;
        }
        /* Removed max-height and overflow-y for mode-indices to show all content */
        .mode-indices {
            /* max-height: 300px; */ /* Removed */
            /* overflow-y: auto; */ /* Removed */
            cursor: default; /* Default cursor for the container */
            word-break: break-all; /* Ensure long numbers wrap */
        }
        /* Container for each particle item */
        .mode-index-item-container {
            border-bottom: 1px solid #2f3b4a; /* Subtle separator */
            padding: 4px 0; /* Add some padding */
        }
        .mode-index-item-container:last-child {
            border-bottom: none; /* No border on the last item */
        }
        /* Style for clickable particle name */
        .mode-index-item {
            transition: background-color 0.2s ease;
            cursor: pointer; /* Indicate items are clickable */
            padding: 2px 0; /* Smaller padding for the clickable name */
        }
        .mode-index-item:hover {
            background-color: #2f3b4a; /* Highlight on hover */
        }
        /* Style for the displayed full mode index */
        .full-index-display {
            margin-top: 5px; /* Space below the name */
            padding: 8px; /* Padding inside the display box */
            background-color: #2f3b4a;
            border-radius: 6px;
            font-size: 0.9em;
            word-break: break-all;
            display: none; /* Hidden by default */
        }

        /* Custom scrollbar styles (still included but won't be active without overflow-y) */
        .mode-indices::-webkit-scrollbar {
            width: 8px;
        }
        .mode-indices::-webkit-scrollbar-track {
            background: #1f2833;
            border-radius: 10px;
        }
        .mode-indices::-webkit-scrollbar-thumb {
            background: #45a29e;
            border-radius: 10px;
        }
        .mode-indices::-webkit-scrollbar-thumb:hover {
            background: #66fcf1;
        }
        /* Added min-height to the display area to prevent jumping */
        #display {
            min-height: 200px; /* Adjust this value as needed */
            overflow-y: auto; /* Add scrollbar if content exceeds height */
            max-width: 100%; /* Ensure it doesn't exceed container width */
            box-sizing: border-box; /* Include padding and border in the element's total width */
        }
         /* Custom scrollbar for the display area */
        #display::-webkit-scrollbar {
            width: 8px;
        }
        #display::-webkit-scrollbar-track {
            background: #1f2833;
            border-radius: 10px;
        }
        #display::-webkit-scrollbar-thumb {
            background: #45a29e;
            border-radius: 10px;
        }
        #display::-webkit-scrollbar-thumb:hover {
            background: #66fcf1;
        }

        /* Style for the info section */
        .info-section {
            margin-top: 20px;
            padding: 15px;
            background-color: #2f3b4a;
            border-radius: 8px;
            color: #c5c6c7;
            font-size: 0.9em;
        }
        .info-section strong {
            color: #66fcf1;
        }
    </style>
</head>
<body class="bg-[#0b0c10] text-[#ffffff] flex justify-center items-center min-h-screen p-4 overflow-x-hidden">
    <div class="calculator bg-[#1f2833] rounded-2xl p-8 shadow-2xl w-full max-w-6xl flex flex-col md:flex-row">
        <div class="left flex-1 md:pr-8 md:border-r-2 md:border-[#c5c6c7] mb-8 md:mb-0">
            <div class="title text-3xl md:text-4xl mb-6 text-[#66fcf1] text-center font-bold">Chronogenesis Mass Calculator</div>

            <div id="display" class="screen bg-[#45a29e] text-[#1f2833] p-6 rounded-xl text-lg mb-6 min-h-[200px] overflow-wrap break-word leading-relaxed">
                Select a particle or prediction to view data.<br>
                <span class="text-sm text-[#1f2833]">This calculator uses the Chronogenesis model to predict particle masses based on their mode index (n) and a time-curvature relationship (κ).</span>
            </div>

            <div id="confirm-bar" class="confirm-bar text-center mb-6"></div>

            <div id="buttonGrid" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
                </div>

            <div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-3 gap-4 mt-6">
                <button onclick="customN()" class="p-3 rounded-lg font-bold bg-[#c5c6c7] text-[#1f2833] hover:bg-[#66fcf1] transition duration-200">CUSTOM n</button>
                <button onclick="clearDisplay()" class="p-3 rounded-lg font-bold bg-[#c5c6c7] text-[#1f2833] hover:bg-[#66fcf1] transition duration-200">CLEAR</button>
                <button onclick="showFormula()" class="p-3 rounded-lg font-bold bg-[#c5c6c7] text-[#1f2833] hover:bg-[#66fcf1] transition duration-200">FORMULA</button>
            </div>

            <div id="formulaDisplay" class="formula bg-[#1f2833] text-[#66fcf1] p-6 rounded-xl text-lg overflow-wrap break-word hidden mt-6">
                <strong class="text-xl block mb-2">Formula:</strong>
                <code class="block mb-4">
                    m<sub>n</sub> = α * √κ<sub>n</sub>
                </code>
                <p class="mb-2">Where:</p>
                <code class="block">
                    κ<sub>n</sub> = n<sup>0.618</sup> ⋅ log(n + 1)<br>
                    n = mode index<br>
                    α = mass scaling constant (kg / √κ)
                </code>
            </div>

            <div class="info-section">
                <strong>About the Chronogenesis Model:</strong>
                <p class="mt-2">This calculator is based on the Chronogenesis model, which proposes that fundamental particle masses are quantized energy states (modes) of a universal time-curvature field. The mass of a particle is related to its mode index (n) through the formula shown above. The model suggests a deep connection between particle physics and the geometry of spacetime.</p>
            </div>


            <div class="footer mt-8 text-sm text-[#888] text-center">
                CNG: Particle masses validated against PDG/CODATA references. All predicted values arise from a single eigenmode curve (n, λ, κₙ) defined in the Chronogenesis v1.2 dataset.
            </div>
        </div>

        <div class="right flex-1 md:pl-8">
            <div class="mt-8 text-center md:mt-0"> <img src="chronogenesis_eigenmode_curve.png" alt="Eigenmode Curve" class="responsive-img rounded-xl border border-[#444]">
            </div>

            <div class="mt-8 bg-[#0b0c10] text-[#ccc] p-6 rounded-xl text-sm leading-relaxed mode-indices" id="modeIndicesListContainer">
                <strong class="text-[#66fcf1] text-base block mb-2">Refined Mode Indices (n):</strong>
                </div>
        </div>
    </div>
</body>
<script>
const Decimal = window.Decimal;

// Configure Decimal.js to prevent exponential notation for large numbers unless necessary
Decimal.set({ toExpNeg: -100, toExpPos: 100 });

const particleData = {
    'Electron': { n: new Decimal("1.116146374259776000504792200600740088568081211715959874293260467558912066286342598811550851149432149E+37"), massMeV: new Decimal("0.511"), massKg: new Decimal("9.1094024112e-31"), spin: 0.5, charge: "-1" },
    'Muon': { n: new Decimal("2.592697864681657296450146244390652422592537772891046634886736363692579682058059087602050186683604189E+44"), massMeV: new Decimal("105.658"), massKg: new Decimal("1.8835249314336e-28"), spin: 0.5, charge: "-1" },
    'Tau': { n: new Decimal("2.095680986337253170258875675748172910666647047613700720984627636052801619803503286417059292660495776E+48"), massMeV: new Decimal("1776.86"), massKg: new Decimal("3.1675406591712e-27"), spin: 0.5, charge: "-1" },
    'Up Quark': { n: new Decimal("1.088836195890027612641435350014546608150713460429511408040403495603282986892407218405437160237667553E+39"), massMeV: new Decimal("2.16"), massKg: new Decimal("3.8505497472e-30"), spin: 0.5, charge: "+2/3" },
    'Down Quark': { n: new Decimal("1.264009938464596673844966914217987937065316705487175044408268624382571444972162533651758797313978983E+40"), massMeV: new Decimal("4.67"), massKg: new Decimal("8.3250311664e-30"), spin: 0.5, charge: "-1/3" },
    'Strange Quark': { n: new Decimal("1.726633093608591886026315041941475948780201682689921345272257534636237409991027301458637758034128428E+44"), massMeV: new Decimal("93.0"), massKg: new Decimal("1.65787558560e-28"), spin: 0.5, charge: "-1/3" },
    'Charm Quark': { n: new Decimal("7.270450020494929955740010279766893379502342245023524796826783304614667014773359912993262006503620785E+47"), massMeV: new Decimal("1275.0"), massKg: new Decimal("2.272893948000e-27"), spin: 0.5, charge: "+2/3" },
    'Bottom Quark': { n: new Decimal("3.21096191571610331850757003649713130046128609586401166643683559161870481286095864011666436835591618704812796308377279745152580586885E+49"), massMeV: new Decimal("4180.0"), massKg: new Decimal("7.451526825600e-27"), spin: 0.5, charge: "-1/3" },
    'Top Quark': { n: new Decimal("4.651419918945756274111528049292917059116238893390426300227887923322275464970993060385669332631062020E+54"), massMeV: new Decimal("172760.0"), massKg: new Decimal("3.07972673299200e-25"), spin: 0.5, charge: "+2/3" },
    'Electron Neutrino': { n: new Decimal("4.785985134579887317477263205775043550151598196481330037114055446129654035793133898715562622692070030E+15"), massMeV: new Decimal("8.3e-8"), massKg: new Decimal("1.4796093936e-37"), spin: 0.5, charge: "0" },
    'Muon Neutrino': { n: new Decimal("1.096272292418038578417998567555555293953541797788583513878935656016903791909266599896029373114823482E+26"), massMeV: new Decimal("0.00017"), massKg: new Decimal("3.030525264e-34"), spin: 0.5, charge: "0" },
    'Tau Neutrino': { n: new Decimal("4.265362646684764673113288026757181623709717578980016381397855225624154285667626703797760605707288949E+31"), massMeV: new Decimal("0.01"), massKg: new Decimal("1.78266192e-32"), spin: 0.5, charge: "0" },
    'Photon': { n: new Decimal("0"), massMeV: new Decimal("0"), massKg: new Decimal("0"), spin: 1, charge: "0" },
    'Gluon': { n: new Decimal("0"), massMeV: new Decimal("0"), massKg: new Decimal("0"), spin: 1, charge: "0" },
    'Graviton': { n: new Decimal("0"), massMeV: new Decimal("0"), massKg: new Decimal("0"), spin: 2, charge: "0" },
    'W Boson': { n: new Decimal("4.036085307766214873433443189812547753999403904296589500223267049268569767308755430179131598933931338E+53"), massMeV: new Decimal("80379.0"), massKg: new Decimal("1.43288582467680e-25"), spin: 1, charge: "±1" },
    'Z Boson': { n: new Decimal("6.039398982388116321671579194641872927161651630537805218977885250419202729193657965618377959764270366E+53"), massMeV: new Decimal("91187.6"), massKg: new Decimal("1.62556662096192e-25"), spin: 1, charge: "0" },
    'Higgs Boson': { n: new Decimal("1.658406012128395459983844710359379460541422054894899713401688352608020961902278624762480085545597019E+54"), massMeV: new Decimal("125100.0"), massKg: new Decimal("2.23011006192000e-25"), spin: 0, charge: "0" }
};

const mevToKg = new Decimal("1.78266192e-30"); // Conversion factor MeV/c^2 to kg

// Calculate the alpha constant using Electron data
const kappaElectron = new Decimal("6.7060821879436456799748104656833798181752300741342e+24");
const alphaMeV = particleData['Electron'].massMeV.div(kappaElectron.sqrt());

// Hardcoded mode indices for CNG predictions
const cngPredictionN1 = new Decimal("1.3771423946537758804255e+52");
const cngPredictionN2 = new Decimal("3.9284999846221127751102e+56");

// Define practical limits for custom input to avoid computational issues
const N_MAX_LIMIT = new Decimal("1e300"); // Example: Limit to avoid excessive computation/memory
const N_MIN_LIMIT = new Decimal("1e-300"); // Example: Limit to avoid issues with log of very small numbers


// Function to calculate the curvature kappa(n)
function curvatureKappa(n) {
    const N = new Decimal(n);
     // Check if n is finite and non-negative before calculating log
    if (!N.isFinite() || N.lt(0)) {
        console.error("Invalid input for curvatureKappa: n must be a finite, non-negative number.");
        return new Decimal(NaN); // Return NaN for invalid input
    }
    // Ensure n+1 is positive for log
    if (N.plus(1).lte(0)) {
        console.error("Logarithm input (n+1) must be positive.");
        return new Decimal(NaN); // Return NaN for invalid input
    }
    const kappa = N.pow(0.618).times(N.plus(1).ln());
    // Check if kappa is finite after calculation
    if (!kappa.isFinite()) {
         console.error("Curvature calculation resulted in non-finite value.");
         return new Decimal(NaN);
    }
    return kappa;
}

// Function to calculate predicted mass in MeV
function massMeV(n) {
    const kappa = curvatureKappa(n);
    if (kappa.isNaN() || !kappa.isFinite() || kappa.lt(0)) { // Check for NaN, Infinity, or negative kappa
        console.error("Invalid kappa for massMeV calculation.");
        return new Decimal(NaN);
    }
    const mass = alphaMeV.times(kappa.sqrt());
     // Check if mass is finite after calculation
    if (!mass.isFinite()) {
         console.error("Mass calculation resulted in non-finite value.");
         return new Decimal(NaN);
    }
    return mass;
}

// Function to calculate predicted mass in Kg
function massKg(n) {
    const kappa = curvatureKappa(n);
     if (kappa.isNaN() || !kappa.isFinite() || kappa.lt(0)) { // Check for NaN, Infinity, or negative kappa
        console.error("Invalid kappa for massKg calculation.");
        return new Decimal(NaN);
    }
    const mass = alphaMeV.times(kappa.sqrt()).times(mevToKg);
     // Check if mass is finite after calculation
    if (!mass.isFinite()) {
         console.error("Mass calculation resulted in non-finite value.");
         return new Decimal(NaN);
    }
    return mass;
}

// Function to calculate percentage alignment between predicted and observed values
// This function will still use standard numbers for calculation as percentages are approximations
function calculateAlignment(predicted, observed) {
    // Ensure inputs are standard numbers for calculation and are finite
    const predNum = parseFloat(predicted.toString());
    const obsNum = parseFloat(observed.toString());

    if (!isFinite(predNum) || !isFinite(obsNum)) {
        return 'N/A';
    }

    // Handle cases where observed is zero to avoid division by zero
    if (obsNum === 0 && predNum === 0) {
        return '100%';
    }
     if (obsNum === 0) { // Predicted is non-zero, observed is zero
         return 'N/A';
     }

    const avg = (Math.abs(predNum) + Math.abs(obsNum)) / 2;
    const diff = Math.abs(predNum - obsNum);
    // Avoid division by zero if avg is zero
    return (avg === 0) ? 'N/A' : (100 * (1 - diff / avg)).toFixed(6) + '%';
}

// Function to get mass data for a given mode index n
function getMassData(n) {
    const predictedMeV = massMeV(n);
    const predictedKg = massKg(n);
    const curvature = curvatureKappa(n);

    // Handle potential NaN or Infinity results from calculations and return appropriate strings
    // predictedMeVDisplay remains as toString()
    const predictedMeVDisplay = predictedMeV.isNaN() || !predictedMeV.isFinite() ? 'N/A' : predictedMeV.toString();
    // Display predictedKg in scientific notation
    const predictedKgDisplay = predictedKg.isNaN() || !predictedKg.isFinite() ? 'N/A' : predictedKg.toExponential();
    // Display curvature in scientific notation
    const curvatureDisplay = curvature.isNaN() || !curvature.isFinite() ? 'N/A' : curvature.toExponential();

    return { predictedMeV: predictedMeVDisplay, predictedKg: predictedKgDisplay, curvature: curvatureDisplay };
}

// Function to display particle data in the screen (triggered by left buttons)
function showParticle(name) {
    try {
        const p = particleData[name];
        const { predictedMeV, predictedKg, curvature } = getMassData(p.n);

        // Calculate alignment using Decimal objects and then convert to number for calculation
        const alignmentMeV = p.massMeV.gt(0) ? calculateAlignment(predictedMeV, p.massMeV) : 'N/A';
        const alignmentKg = p.massKg.gt(0) ? calculateAlignment(predictedKg, p.massKg) : 'N/A';

        // Display a fixed placeholder for the mode index in the main display
        const displayN = "[See list on right]";


        // Determine spin label
        let spinLabel;
        switch (p.spin) {
            case 0: spinLabel = 'Scalar Boson (spin 0)'; break;
            case 0.5: spinLabel = 'Fermion (spin ½)'; break;
            case 1: spinLabel = 'Vector Boson (spin 1)'; break;
            case 2: spinLabel = 'Tensor Boson (spin 2)'; break;
            default: spinLabel = `Spin: ${p.spin}`;
        }

        // Custom display for Electron Neutrino measured mass
        let measuredMeVDisplay = p.massMeV.toString(); // Display full precision for measured MeV
        if (name === 'Electron Neutrino') measuredMeVDisplay = "< 0.00045"; // Keep the specific neutrino notation


        document.getElementById("display").innerHTML = `
            <strong>${name}</strong><br>
            Mode Index: ${displayN}<br>
            Measured MeV: ${measuredMeVDisplay} MeV<br>
            Predicted MeV: ${predictedMeV} MeV<br>
            Measured Mass (CODATA): ${p.massKg.toExponential()} kg<br> Predicted Mass: ${predictedKg} kg<br>
            Time-Curvature Mode κ<sub>n</sub> (unitless): ${curvature}<br>
            ${spinLabel}<br>
            Charge: ${p.charge}<br>
            Alignment (MeV): ${alignmentMeV}<br>
            Alignment (kg): ${alignmentKg}<br>
        `;

        // Display perfect match message if alignment is very high and values are finite
        if (alignmentMeV.startsWith('100.') && alignmentKg.startsWith('100.') && isFinite(parseFloat(predictedMeV)) && isFinite(parseFloat(predictedKg))) {
            document.getElementById("display").innerHTML += `<br><strong class="text-[#00ff88]">Perfect Match ✔</strong>`;
        }

        // Check and display if the mode is in a resonant stability valley
        if (isResonantValley(p.n)) {
            document.getElementById("display").innerHTML += `<br><strong class="text-[#66fcf1]">Resonant Stability Valley ✔</strong>`;
        }
    } catch (error) {
        console.error("Error in showParticle:", error);
        document.getElementById("display").innerHTML = `<strong class="text-red-500">Error displaying particle data.</strong>`;
    }
}

// Function to display CNG Prediction data in the screen
function showCngPrediction(predictionNumber, n) {
    try {
        const { predictedMeV, predictedKg, curvature } = getMassData(n);

        // Display a fixed placeholder for the mode index in the main display
        const displayN = "[See list on right]";

        // Estimate spin based on whether n's floor is even or odd
        let spinEstimate = 'Unknown';
        // Only estimate spin if n is a positive finite number
        if (n.isFinite() && n.gt(0)) {
            const nFloor = n.floor();
             if (nFloor.mod(2).equals(0)) {
                 spinEstimate = 'Boson (even mode)';
             } else {
                 spinEstimate = 'Fermion (odd mode)';
             }
        }

        let spinDescription = '';
        if (spinEstimate === 'Fermion (odd mode)') {
            spinDescription = '— matter';
        } else if (spinEstimate === 'Boson (even mode)') {
            spinDescription = '— force carrier';
        }


        let valleyStatus = '';
        // Only check for resonant valley if predicted values are finite
        if (isResonantValley(n) && isFinite(parseFloat(predictedMeV)) && isFinite(parseFloat(predictedKg))) {
            valleyStatus = `<br><strong class="text-[#66fcf1]">Resonant Stability Valley ✔</strong>`;
        }


        document.getElementById("display").innerHTML = `
            <strong>CNG Prediction ${predictionNumber}</strong><br>
            Mode Index: ${displayN}<br>
            Predicted MeV: ${predictedMeV} MeV<br>
            Predicted Mass: ${predictedKg} kg<br>
            Time-Curvature Mode κ<sub>n</sub> (unitless): ${curvature}<br>
            Spin Estimate: ${spinEstimate} ${spinDescription}<br>
            (Electron-calibrated)
            ${valleyStatus}
        `;
    } catch (error) {
        console.error("Error in showCngPrediction:", error);
        document.getElementById("display").innerHTML = `<strong class="text-red-500">Error displaying prediction data.</strong>`;
    }
}


// Function to handle custom mode index input (triggered by left button)
function customN() {
    try {
        const nInput = prompt("Enter mode index n:");
        if (nInput === null) return; // User cancelled prompt

        let n;
        try {
            n = new Decimal(nInput);
        } catch (e) {
            // Handle Decimal.js parsing errors
            alert("Invalid input. Please enter a valid number.");
            console.error("Decimal.js parsing error:", e);
            return;
        }

        // Add more robust validation for custom input
        if (!n.isFinite() || n.lt(0)) { // Check for non-finite or negative
            alert("Invalid input. Please enter a non-negative finite number.");
            console.error("Invalid custom input: not finite or negative.", n);
            return;
        }

        // Add checks for extremely large/small values that might cause issues
        if (n.abs().gt(N_MAX_LIMIT)) {
             alert(`Input too large. Please enter a value less than or equal to ${N_MAX_LIMIT.toExponential()}.`);
             console.error("Invalid custom input: exceeds max limit.", n);
             return;
        }
         if (n.abs().lt(N_MIN_LIMIT) && !n.equals(0)) {
             alert(`Input too small. Please enter a value greater than or equal to ${N_MIN_LIMIT.toExponential()} or exactly 0.`);
             console.error("Invalid custom input: below min limit (and not zero).", n);
             return;
         }


        const { predictedMeV, predictedKg, curvature } = getMassData(n);

        // Display a fixed placeholder for the mode index in the main display
        const displayN = "[See list on right]";

        // Estimate spin based on whether n is close to an integer
        let spinEstimate = 'Unknown';
         // Only estimate spin if n is a positive finite number and close to an integer
        if (n.isFinite() && n.gt(0)) {
            const nFloor = n.floor();
            const nCeil = n.ceil();
            const diffFloor = n.minus(nFloor).abs();
            const diffCeil = n.minus(nCeil).abs();
            const tolerance = new Decimal("1e-9"); // Tolerance for checking if n is close to an integer

            if (diffFloor.lt(tolerance) || diffCeil.lt(tolerance)) {
                const closestInt = diffFloor.lt(tolerance) ? nFloor : nCeil;
                if (closestInt.mod(2).equals(0)) {
                     spinEstimate = 'Boson (even mode)';
                } else {
                     spinEstimate = 'Fermion (odd mode)';
                }
            }
        }


        let spinDescription = '';
        if (spinEstimate === 'Fermion (odd mode)') {
            spinDescription = '— matter';
        } else if (spinEstimate === 'Boson (even mode)') {
            spinDescription = '— force carrier';
        }

        let valleyStatus = '';
         // Only check for resonant valley if predicted values are finite
        if (isResonantValley(n) && isFinite(parseFloat(predictedMeV)) && isFinite(parseFloat(predictedKg))) {
            valleyStatus = `<br><strong class="text-[#66fcf1]">Resonant Stability Valley ✔</strong>`;
        }


        document.getElementById("display").innerHTML = `
            <strong>Custom Mode</strong><br>
            n = ${displayN}<br>
            Predicted MeV: ${predictedMeV} MeV<br>
            Mass: ${predictedKg} kg<br>
            Time-Curvature Mode κ<sub>n</sub> (unitless): ${curvature}<br>
            Spin Estimate: ${spinEstimate} ${spinDescription}<br>
            (Electron-calibrated)
            ${valleyStatus}
        `;
    } catch (error) {
        console.error("Error in customN:", error);
        document.getElementById("display").innerHTML = `<strong class="text-red-500">Error calculating custom mode data.</strong>`;
    }
}

// Function to clear the display screen (triggered by left button)
function clearDisplay() {
    document.getElementById("display").innerText = "Select a particle or prediction to view data.";
}

// Function to toggle the visibility of the formula display
function showFormula() {
    const formulaDisplay = document.getElementById("formulaDisplay");
    if (formulaDisplay) {
        formulaDisplay.classList.toggle('hidden'); // Use Tailwind's hidden class
    }
}

// Function to render the particle buttons and CNG prediction buttons in the left section
function renderButtons() {
    try {
        const grid = document.getElementById("buttonGrid");
        if (!grid) return;
        grid.innerHTML = ''; // Clear existing buttons

        // Render standard particle buttons
        Object.keys(particleData).forEach(p => {
            const btn = document.createElement("button");
            btn.textContent = p;
            // Add Tailwind classes for styling
            btn.classList.add('p-3', 'rounded-lg', 'font-bold', 'bg-[#c5c6c7]', 'text-[#1f2833]', 'hover:bg-[#66fcf1]', 'transition', 'duration-200');
            btn.onclick = () => showParticle(p);
            grid.appendChild(btn);
        });

        // Render CNG Prediction buttons
        const cng1Btn = document.createElement("button");
        cng1Btn.textContent = "CNG Prediction 1";
        cng1Btn.classList.add('p-3', 'rounded-lg', 'font-bold', 'bg-[#c5c6c7]', 'text-[#1f2833]', 'hover:bg-[#66fcf1]', 'transition', 'duration-200');
        cng1Btn.onclick = () => showCngPrediction(1, cngPredictionN1);
        grid.appendChild(cng1Btn);

        const cng2Btn = document.createElement("button");
        cng2Btn.textContent = "CNG Prediction 2";
        cng2Btn.classList.add('p-3', 'rounded-lg', 'font-bold', 'bg-[#c5c6c7]', 'text-[#1f2833]', 'hover:bg-[#66fcf1]', 'transition', 'duration-200');
        cng2Btn.onclick = () => showCngPrediction(2, cngPredictionN2);
        grid.appendChild(cng2Btn);
    } catch (error) {
        console.error("Error rendering buttons:", error);
    }
}

// Function to render the clickable mode indices list in the right section
function renderModeIndicesList() {
    try {
        const modeIndicesListContainer = document.getElementById("modeIndicesListContainer");
        if (!modeIndicesListContainer) return;

        // Clear existing content except the strong tag title
        const titleTag = modeIndicesListContainer.querySelector('strong');
        modeIndicesListContainer.innerHTML = '';
        if (titleTag) {
            modeIndicesListContainer.appendChild(titleTag);
        } else {
             // If title wasn't found, add it back
             const strongTag = document.createElement('strong');
             strongTag.classList.add('text-[#66fcf1]', 'text-base', 'block', 'mb-2');
             strongTag.textContent = 'Refined Mode Indices (n):';
             modeIndicesListContainer.appendChild(strongTag);
        }

        Object.keys(particleData).forEach(pName => {
            const p = particleData[pName];

            // Create a container for each particle item
            const itemContainer = document.createElement("div");
            itemContainer.classList.add('mode-index-item-container');

            // Create the clickable particle name element
            const nameDiv = document.createElement("div");
            nameDiv.classList.add('mode-index-item'); // Add class for styling and targeting
            nameDiv.textContent = pName; // Display particle name
            nameDiv.dataset.particleName = pName; // Store particle name for click handling

            // Create the hidden div for displaying the full index
            const fullIndexDiv = document.createElement("div");
            fullIndexDiv.classList.add('full-index-display'); // Add class for styling and targeting

            // Append name and full index div to the item container
            itemContainer.appendChild(nameDiv);
            itemContainer.appendChild(fullIndexDiv);

            // Append the item container to the main list container
            modeIndicesListContainer.appendChild(itemContainer);
        });

        // Add click event listener to the main mode indices list container
        modeIndicesListContainer.addEventListener('click', function(event) {
            try {
                const target = event.target;
                // Check if the clicked element is a particle name item
                if (target && target.classList.contains('mode-index-item')) {
                    const particleName = target.dataset.particleName;
                    if (particleName && particleData[particleName]) {
                        displayFullModeIndex(target.closest('.mode-index-item-container'), particleName); // Pass the container and name
                    }
                } else {
                    // If click is not on an item, hide all full displays
                    hideAllFullModeIndices();
                }
            } catch (error) {
                console.error("Error in modeIndicesListContainer click handler:", error);
            }
        });
    } catch (error) {
        console.error("Error rendering mode indices list:", error);
    }
}

// Function to display the full mode index for a selected particle, under its name
function displayFullModeIndex(itemContainer, particleName) {
    const fullDisplayElement = itemContainer.querySelector('.full-index-display');
    const particle = particleData[particleName];

    if (fullDisplayElement && particle) {
        // Hide any currently displayed full indices first
        hideAllFullModeIndices();

        // Display the full, unrounded mode index
        fullDisplayElement.innerHTML = `<strong>Mode Index (n):</strong> ${particle.n.toString()}`;
        fullDisplayElement.style.display = 'block'; // Show the element
    }
}

// Function to hide all currently displayed full mode indices
function hideAllFullModeIndices() {
    const allFullDisplays = document.querySelectorAll('.full-index-display');
    allFullDisplays.forEach(el => {
        el.style.display = 'none';
        el.innerHTML = ''; // Clear content when hidden
    });
}


// Function to check if a mode index is in a resonant stability valley (based on second derivative of mass)
function isResonantValley(n) {
    // Use a relative delta based on n for better accuracy with large numbers
    // Ensure n is a positive finite number before calculating delta
     if (!n.isFinite() || n.lt(0)) {
        return false; // Cannot calculate derivative for non-finite or negative n
    }
    const delta = n.times("1e-6");


    // Ensure n +/- delta are positive for curvatureKappa
    if (n.minus(delta).lte(0) || n.plus(delta).lte(0)) {
        return false; // Cannot calculate derivative if n is too small
    }

    const m1 = massMeV(n.minus(delta));
    const m2 = massMeV(n);
    const m3 = massMeV(n.plus(delta));

    // Check for NaN or Infinity results from massMeV
    if (m1.isNaN() || !m1.isFinite() || m2.isNaN() || !m2.isFinite() || m3.isNaN() || !m3.isFinite()) {
        return false;
    }

    // Approximate the second derivative using Decimal objects
    const d2 = (m1.minus(m2.times(2)).plus(m3)).div(delta.times(delta));

    // Define a tolerance for considering it a "valley" (where the second derivative is close to zero)
    // The specific tolerance might need tuning based on the function's behavior
    const valleyTolerance = new Decimal("1e-3"); // Example tolerance - adjust as needed

    // A valley corresponds to a local minimum or inflection point where the second derivative is close to zero.
    // For a "stability valley", we might also expect the first derivative to be close to zero (local minimum).
    // Let's focus on the second derivative being close to zero for now.
     return d2.abs().lt(valleyTolerance);
}


// Initial rendering of buttons and mode indices list when the page loads
try {
    renderButtons();
    renderModeIndicesList();
} catch (error) {
    console.error("Error during initial rendering:", error);
}
</script>
</html>
