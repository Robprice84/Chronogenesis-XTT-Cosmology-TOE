<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronogenesis Mass Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/decimal.js@10.4.3/decimal.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #display, .formula, .mode-indices, .full-index-display {
            font-family: 'JetBrains Mono', monospace;
        }
        /* Ensure the image scales correctly */
        .responsive-img {
            max-width: 100%;
            height: auto;
        }
        /* Removed max-height and overflow-y for mode-indices to show all content */
        .mode-indices {
            /* max-height: 300px; */ /* Removed */
            /* overflow-y: auto; */ /* Removed */
            cursor: default; /* Default cursor for the container */
            word-break: break-all; /* Ensure long numbers wrap */
        }
        /* Container for each particle item */
        .mode-index-item-container {
            border-bottom: 1px solid #2f3b4a; /* Subtle separator */
            padding: 4px 0; /* Add some padding */
        }
        .mode-index-item-container:last-child {
            border-bottom: none; /* No border on the last item */
        }
        /* Style for clickable particle name */
        .mode-index-item {
            transition: background-color 0.2s ease;
            cursor: pointer; /* Indicate items are clickable */
            padding: 2px 0; /* Smaller padding for the clickable name */
        }
        .mode-index-item:hover {
            background-color: #2f3b4a; /* Highlight on hover */
        }
        /* Style for the displayed full mode index */
        .full-index-display {
            margin-top: 5px; /* Space below the name */
            padding: 8px; /* Padding inside the display box */
            background-color: #2f3b4a;
            border-radius: 6px;
            font-size: 0.9em;
            word-break: break-all;
            display: none; /* Hidden by default */
        }

        /* Custom scrollbar styles (still included but won't be active without overflow-y) */
        .mode-indices::-webkit-scrollbar {
            width: 8px;
        }
        .mode-indices::-webkit-scrollbar-track {
            background: #1f2833;
            border-radius: 10px;
        }
        .mode-indices::-webkit-scrollbar-thumb {
            background: #45a29e;
            border-radius: 10px;
        }
        .mode-indices::-webkit-scrollbar-thumb:hover {
            background: #66fcf1;
        }
        /* Added min-height to the display area to prevent jumping */
        #display {
            min-height: 200px; /* Adjust this value as needed */
            overflow-y: auto; /* Add scrollbar if content exceeds height */
            max-width: 100%; /* Ensure it doesn't exceed container width */
            box-sizing: border-box; /* Include padding and border in the element's total width */
        }
         /* Custom scrollbar for the display area */
        #display::-webkit-scrollbar {
            width: 8px;
        }
        #display::-webkit-scrollbar-track {
            background: #1f2833;
            border-radius: 10px;
        }
        #display::-webkit-scrollbar-thumb {
            background: #45a29e;
            border-radius: 10px;
        }
        #display::-webkit-scrollbar-thumb:hover {
            background: #66fcf1;
        }

        /* Style for the info section */
        .info-section {
            margin-top: 20px;
            padding: 15px;
            background-color: #2f3b4a;
            border-radius: 8px;
            color: #c5c6c7;
            font-size: 0.9em;
        }
        .info-section strong {
            color: #66fcf1;
        }
         .warning {
            color: #ffcc00; /* Yellow/Orange color for warnings */
            font-weight: bold;
         }
         .error-message {
            color: #ff0000; /* Red color for errors */
            font-weight: bold;
         }
         .highlight-green {
            color: #00ff88; /* Green color for highlights */
         }
         .spin-formulation {
             margin-top: 20px;
             padding: 15px;
             background-color: #2f3b4a;
             border-radius: 8px;
             color: #c5c6c7;
             font-size: 0.9em;
         }
         .spin-formulation strong {
             color: #66fcf1;
         }
         .spin-formulation code {
             display: block;
             margin: 10px 0;
             padding: 10px;
             background-color: #1f2833;
             border-radius: 4px;
             overflow-x: auto; /* Add horizontal scroll for long formulas */
         }
          /* LaTeX rendering for math */
          .latex-math {
              display: inline-block;
              white-space: nowrap; /* Prevent line breaks within math */
              overflow-x: auto; /* Allow horizontal scroll for long equations */
              vertical-align: middle; /* Align with surrounding text */
          }
    </style>
     <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body class="bg-[#0b0c10] text-[#ffffff] flex justify-center items-center min-h-screen p-4 overflow-x-hidden">
    <div class="calculator bg-[#1f2833] rounded-2xl p-8 shadow-2xl w-full max-w-6xl flex flex-col md:flex-row">
        <div class="left flex-1 md:pr-8 md:border-r-2 md:border-[#c5c6c7] mb-8 md:mb-0">
            <div class="title text-3xl md:text-4xl mb-6 text-[#66fcf1] text-center font-bold">Chronogenesis Mass Calculator</div>

            <div id="display" class="screen bg-[#45a29e] text-[#1f2833] p-6 rounded-xl text-lg mb-6 min-h-[200px] overflow-wrap break-word leading-relaxed">
                Select a particle or prediction to view data.<br>
                <span class="text-sm text-[#1f2833]">This calculator uses the Chronogenesis model to predict fundamental particle properties based on their mode index (n) and a time-curvature relationship (κ).</span>
            </div>

            <div id="confirm-bar" class="confirm-bar text-center mb-6"></div>

            <div id="buttonGrid" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4">
                </div>

            <div class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-3 gap-4 mt-6">
                <button onclick="customN()" class="p-3 rounded-lg font-bold bg-[#c5c6c7] text-[#1f2833] hover:bg-[#66fcf1] transition duration-200">CUSTOM n</button>
                <button onclick="clearDisplay()" class="p-3 rounded-lg font-bold bg-[#c5c6c7] text-[#1f2833] hover:bg-[#66fcf1] transition duration-200">CLEAR</button>
                <button onclick="showFormula()" class="p-3 rounded-lg font-bold bg-[#c5c6c7] text-[#1f2833] hover:bg-[#66fcf1] transition duration-200">FORMULA</button>
            </div>

            <div class="info-section">
                <strong>About the Chronogenesis Model:</strong>
                <p class="mt-2">This calculator is based on the Chronogenesis model, which proposes that fundamental particle properties are quantized energy states (modes) of a universal time-curvature field (Θ). The mass spectrum and other properties are derived from the eigenmodes of this field. This tool allows for the calculation of these properties based on the mode index (n) and the time-curvature relationship (κ).</p>
                 <p class="mt-2 text-sm italic">
                    Properties calculated by this tool:
                    <ul>
                        <li><strong>Mass (m<sub>n</sub>):</strong> Predicted from the mode index (n) and time-curvature (κ).</li>
                         <li><strong>Time-Curvature Mode (κ<sub>n</sub>):</strong> A unitless value representing the particle's mode in the time-curvature field.</li>
                         <li><strong>Predicted Spin:</strong> Derived from the topological winding number of the Θ-field eigenmode over a compactified time dimension. This links spin to the fundamental geometry of the field. (Note: This is a model prediction and may not always match the Standard Model spin).</li>
                        <li><strong>Charge (Placeholder/Manual Entry):</strong> The electric charge assigned to the particle mode within the Chronogenesis framework. (Note: Charge is assigned based on the model's framework, not directly predicted by the core mass/kappa formula).</li>
                        <li><strong>Stability/Lifetime:</strong> Resonant stability valleys in the mass spectrum (where the second derivative of mass is near zero) predict longer-lived particles and stable decays. Off-valley modes correspond to unstable resonances.</li>
                         <li><strong>Redshift Origin (z):</strong> Each mode index (n) is linked to a predicted cosmological redshift (z), potentially connecting particles to cosmic structures.</li>
                         <li><strong>Quantum Decoherence Time (τ<sub>D</sub>):</strong> The model provides a formula for the collapse time of superpositions involving a mode based on the difference in the Θ field. (Note: Calculation here uses a simplified $\Delta\kappa = \kappa_n$ and $\Theta=1$).</li>
                         <li><strong>Entropy Contribution (S<sub>n</sub>):</strong> Each particle mode has an associated entropy value ($S_n$).</li>
                         <li><strong>Resonance Shell Layer (k):</strong> Each mode index corresponds to a predicted cosmic shell layer index (k), indicating a particle's position within large-scale cosmic structure.</li>
                    </ul>
                     Other aspects of the broader theory, such as calculating charge directly from topology, visualizing field geometry, and calculating interaction strengths for composite particles, are addressed in theoretical papers or separate tools and are beyond the scope of this calculator.
                </p>
            </div>


            <div class="footer mt-8 text-sm text-[#888] text-center">
                CNG: Particle masses validated against PDG/CODATA references. All predicted values arise from a single eigenmode curve (n, λ, κₙ) defined in the Chronogenesis v1.2 dataset.
            </div>
        </div>

        <div class="right flex-1 md:pl-8">
            <div class="mt-8 text-center md:mt-0"> <img src="chronogenesis_eigenmode_curve.png" alt="Eigenmode Curve" class="responsive-img rounded-xl border border-[#444]">
            </div>

            <div class="mt-8 bg-[#0b0c10] text-[#ccc] p-6 rounded-xl text-sm leading-relaxed mode-indices" id="modeIndicesListContainer">
                <strong class="text-[#66fcf1] text-base block mb-2">Refined Mode Indices (n):</strong>
                </div>

            <div id="formulaDisplay" class="formula bg-[#1f2833] text-[#66fcf1] p-6 rounded-xl text-lg overflow-wrap break-word hidden mt-6">
                <strong class="text-xl block mb-2">Chronogenesis Mass Formula:</strong>
                <code class="block mb-4">
                    $$m_n = \alpha \cdot \sqrt{\kappa_n}$$
                </code>
                <p class="mb-2">Where:</p>
                <code class="block">
                    $$\kappa_n = n^{0.618} \cdot \log(n + 1)$$
                    <span class="text-sm text-[#c5c6c7]">(Time-Curvature Mode, unitless)</span><br>
                    $m_n$ = Mass of the particle mode (in kg or MeV/c<sup>2</sup>)<br>
                    $n$ = Mode index (a large integer)<br>
                    $\alpha$ = Mass scaling constant (calibrated from the electron mass)<br>
                    $\log()$ = Natural logarithm
                </code>
                <p class="mt-4 text-sm text-[#c5c6c7]">
                    This formula relates the quantized mass ($m_n$) of a fundamental particle to its mode index ($n$) through the time-curvature mode ($\kappa_n$). The constant $\alpha$ is determined empirically using a known particle mass (currently the electron).
                </p>

                <div class="spin-formulation mt-8">
                    <strong class="text-xl block mb-2">Topological Spin from Temporal Winding:</strong>
                    <p class="mb-2">
                        Spin ($s_n$) emerges from the winding number ($W_n$) of the $\Theta$-field eigenmode ($\Theta_n$) over compactified time ($x^0 \in [0, 2\pi L]$).
                    </p>
                    <p class="mb-2">
                        Winding number ($W_n$) is the path integral of the field's gradient:
                    </p>
                    <code class="block mb-4">
                        $$W_n = \oint_{S^1} \partial_\mu \Theta_n(x) \, dx^\mu$$
                    </code>
                    <p class="mb-2">
                        For a time-like loop:
                    </p>
                     <code class="block mb-4">
                        $$W_n = \oint \partial_0 \Theta_n(x^0) \, dx^0$$
                    </code>
                     <p class="mb-2">
                        Spin ($s_n$) is the normalized winding number:
                    </p>
                    <code class="block mb-4">
                        $$s_n = \frac{W_n}{2\pi}$$
                    </code>
                    <p class="mb-2">
                        This predicts a discrete spin spectrum based on integer $W_n$:
                    </p>
                    <table class="min-w-full bg-[#1f2833] text-[#c5c6c7] rounded-md overflow-hidden">
                        <thead>
                            <tr>
                                <th class="py-2 px-4 border-b border-[#2f3b4a] text-left text-[#66fcf1]">Winding Number ($W_n$)</th>
                                <th class="py-2 px-4 border-b border-[#2f3b4a] text-left text-[#66fcf1]">Predicted Spin ($s_n$)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">0</td>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">0</td>
                            </tr>
                             <tr>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">$\pm 1$</td>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">0.5</td>
                            </tr>
                             <tr>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">$\pm 2$</td>
                                <td class="py-2 px-4 border-b border-[#2f3b4a]">1</td>
                            </tr>
                             <tr>
                                <td class="py-2 px-4">$\pm 4$</td>
                                <td class="py-2 px-4">2</td>
                            </tr>
                        </tbody>
                    </table>
                     <p class="mt-4 text-sm text-[#c5c6c7]">
                         Parameter-free spin from field geometry.
                     </p>
                </div>
                </div>
        </div>
    </div>
</body>
<script>
const Decimal = window.Decimal;

// Configure Decimal.js to prevent exponential notation for large numbers unless necessary
// Reverting to v2.17 precision settings as requested
Decimal.set({
  toExpNeg: -100,
  toExpPos: 100,
  precision: 150 // Increased precision for calculations involving large numbers
});

// Define which particles are composite and require the composite mass formula
const compositeParticles = ['Proton', 'Neutron'];

// Particle data including fundamental and composite (with placeholder for sub-modes)
const particleData = {
    'Electron': { n: new Decimal("1.116146374259776000504792200600740088568081211715959874293260467558912066286342598811550851149432149E+37"), massMeV: new Decimal("0.5109989461"), massKg: new Decimal("9.1093837015e-31"), spin: 0.5, charge: "-1" }, // Using more precise CODATA 2018 values
    'Muon': { n: new Decimal("2.592697864681657296450146244390652422592537772891046634886736363692579682058059087602050186683604189E+44"), massMeV: new Decimal("105.6584135"), massKg: new Decimal("1.883531594e-28"), spin: 0.5, charge: "-1" }, // Using more precise CODATA 2018 values
    'Tau': { n: new Decimal("2.095680986337253170258875675748172910666647047613700720984627636052801619803503286417059292660495776E+48"), massMeV: new Decimal("1776.86"), massKg: new Decimal("3.1675406591712e-27"), spin: 0.5, charge: "-1" },
    'Up Quark': { n: new Decimal("1.088836195890027612641435350014546608150713460429511408040403495603282986892407218405437160237667553E+39"), massMeV: new Decimal("2.16"), massKg: new Decimal("3.8505497472e-30"), spin: 0.5, charge: "+2/3" },
    'Down Quark': { n: new Decimal("1.264009938464596673844966914217987937065316705487175044408268624382571444972162533651758797313978983E+40"), massMeV: new Decimal("4.67"), massKg: new Decimal("8.3250311664e-30"), spin: 0.5, charge: "-1/3" },
    'Strange Quark': { n: new Decimal("1.726633093608591886026315041941475948780201682689921345272257534636237409991027301458637758034128428E+44"), massMeV: new Decimal("93.0"), massKg: new Decimal("1.65787558560e-28"), spin: 0.5, charge: "-1/3" },
    'Charm Quark': { n: new Decimal("7.270450020494929955740010279766893379502352479682678330461466664704761619803503286417059292660495776E+47"), massMeV: new Decimal("1275.0"), massKg: new Decimal("2.272893948000e-27"), spin: 0.5, charge: "+2/3" },
    'Bottom Quark': { n: new Decimal("3.21096191571610331850757003649713130046128609586401166643683559161870481286095864011666436835591618704812796308377279745152580586885E+49"), massMeV: new Decimal("4180.0"), massKg: new Decimal("7.451526825600e-27"), spin: 0.5, charge: "-1/3" },
    'Top Quark': { n: new Decimal("4.651419918945756274111528049292917059116238893390426300227887923322275464970993060385669332631062020E+54"), massMeV: new Decimal("172760.0"), massKg: new Decimal("3.07972673299200e-25"), spin: 0.5, charge: "+2/3" },
    'Electron Neutrino': { n: new Decimal("4.785985134579887317477263205775043550151598196481330037114055446129654035793133898715562622692070030E+15"), massMeV: new Decimal("8.3e-8"), massKg: new Decimal("1.4796093936e-37"), spin: 0.5, charge: "0" },
    'Muon Neutrino': { n: new Decimal("1.096272292418038578417998567555555293953541797788583513878935656016903791909266599896029373114823482E+26"), massMeV: new Decimal("0.00017"), massKg: new Decimal("3.030525264e-34"), spin: 0.5, charge: "0" },
    'Tau Neutrino': { n: new Decimal("4.265362646684764673113288026757181623709717578980016381397855225624154285667626703797760605707288949E+31"), massMeV: new Decimal("0.01"), massKg: new Decimal("1.78266192e-32"), spin: 0.5, charge: "0" },
    'Photon': { n: new Decimal("0"), massMeV: new Decimal("0"), massKg: new Decimal("0"), spin: 1, charge: "0" },
    'Gluon': { n: new Decimal("0"), massMeV: new Decimal("0"), massKg: new Decimal("0"), spin: 1, charge: "0" },
    'Graviton': { n: new Decimal("0"), massMeV: new Decimal("0"), massKg: new Decimal("0"), spin: 2, charge: "0" },
    'W Boson': { n: new Decimal("4.036085307766214873433443189812547753999403904296589500223267049268569767308755430179131598933931338E+53"), massMeV: new Decimal("80379.0"), massKg: new Decimal("1.43288582467680e-25"), spin: 1, charge: "±1" },
    'Z Boson': { n: new Decimal("6.039398982388116321671579194641872927161651630537805218977885250419202729193657964270366E+53"), massMeV: new Decimal("91187.6"), massKg: new Decimal("1.62556662096192e-25"), spin: 1, charge: "0" },
    'Higgs Boson': { n: new Decimal("1.658406012128395459983844710359379460541422054894899713401688352608020961902278624762480085545597019E+54"), massMeV: new Decimal("125100.0"), massKg: new Decimal("2.23011006192000e-25"), spin: 0, charge: "0" },
    // Added CNG Prediction 1 data
    'CNG Prediction 1': { n: new Decimal("3.1622776601683793319988935444327185337195551393252168268575048527484605778802671417582059499319701460e+35"), massMeV: new Decimal("27913.8699999999989813659340143203735351562500000000000000000000"), massKg: new Decimal("0.0000000000000000000000000497609900000000021102310454340774472"), spin: 'See SM Spin / CNG Interpretation', charge: "N/A (Electron-calibrated)" },
    // Added CNG Prediction 2 data
    'CNG Prediction 2': { n: new Decimal("5.6234132519034908385097000365155400518654492540361421009492647363456122812603182958813037980753701856e+35"), massMeV: new Decimal("692303.4000000000232830643653869628906250000000000000000000000000"), massKg: new Decimal("0.0000000000000000000000012341429999999999761507075425760540424"), spin: 'See SM Spin / CNG Interpretation', charge: "N/A (Electron-calibrated)" }
};

// NOTE: Proton and Neutron are composite particles, their 'n' values and properties here
// are based on the Chronogenesis model's interpretation of their composite modes,
// not fundamental single modes like the leptons and quarks.
const compositeParticleData = {
     'Proton': {
         // Using the overall n from the Chronogenesis dataset for other properties (like shell location)
         n: new Decimal("1.774015855819727177401585581972717740158558197271774015855819727177401585581972717740158558197271774E+40"),
         massMeV: new Decimal("938.27208816"), // Using the precise PDG value for comparison
         massKg: new Decimal("1.67262192369e-27"), // Using the precise CODATA value for comparison
         spin: 0.5,
         charge: "+1",
         // Explicitly providing the sub-mode indices for Proton (u, u, d) for composite mass calculation
         // Using the exact unrounded quark indices from project files
         subModes: [
             new Decimal("1.088836195890027612641435350014546608150713460429511408040403495603282986892407218405437160237667553E+39"), // n_u(1)
             new Decimal("1.088836195890027612641435350014546608150713460429511408040403495603282986892407218405437160237667553E+39"), // n_u(2)
             new Decimal("1.264009938464596673844966914217987937065316705487175044408268624382571444972162533651758797313978983E+40")  // n_d
         ],
         subModeNames: ['u', 'u', 'd'] // Names for display
     },
     'Neutron': {
         // Using the overall n from the Chronogenesis dataset for other properties (like shell location)
         n: new Decimal("1.7758528914340380702431901388836195890027612641435350014546608150713460429511408040403495603282986892407218405437160237667553E+40"),
         massMeV: new Decimal("939.56542052"), // Using the precise PDG value for comparison
         massKg: new Decimal("1.67492749804e-27"), // Using the precise CODATA value for comparison
         spin: 0.5,
         charge: "0",
         // Explicitly providing the sub-mode indices for Neutron (d, d, u) for composite mass calculation
         // Using the exact unrounded quark indices from project files
         subModes: [
             new Decimal("1.264009938464596673844966914217987937065316705487175044408268624382571444972162533651758797313978983E+40"), // n_d(1)
             new Decimal("1.26400993846459667384496673844966914217987937065316705487175044408268624382571444972162533651758797313978983E+40"), // n_d(2)
             new Decimal("1.088836195890027612641435350014546608150713460429511408040403495603282986892407218405437160237667553E+39")  // n_u
         ],
         subModeNames: ['d', 'd', 'u'] // Names for display
     }
};

// Combine fundamental and composite particle data for rendering buttons and list
const allParticleData = { ...particleData, ...compositeParticleData };


const mevToKg = new Decimal("1.78266192e-30"); // Conversion factor MeV/c^2 to kg

// Fundamental constants (using Decimal.js)
const PLANCK_REDUCED = new Decimal("1.054571817e-34"); // Reduced Planck constant in J*s
const BOLTZMANN_CONSTANT = new Decimal("1.380649e-23"); // Boltzmann constant in J/K (for entropy interpretation)

// Chronogenesis constants (using Decimal.js)
const BETA_REDSHIFT = new Decimal("1.97e-4"); // Beta constant for redshift calculation
const THETA_FIELD = new Decimal("1"); // Theta field value (naturalized units)
const BETA_ENTROPY = new Decimal("1.44e-24"); // Beta constant for entropy calculation (Planck-normalized J/K)
const SHELL_A = new Decimal("1.43"); // Constant 'a' for shell layer calculation
const SHELL_B = new Decimal("3.11"); // Constant 'b' for shell layer calculation
const LN10 = new Decimal('2.302585092994045684017991'); // ln(10) for base-10 logarithm conversion


// Define placeholder coefficients for the triple-interaction term (these need to be solved for)
// Setting to 0 for now, so the delta_ijk calculated by the formula is zero.
const DELTA_A = new Decimal(0); // Placeholder coefficient 'a'
const DELTA_B = new Decimal(0); // Placeholder coefficient 'b'
const DELTA_C = new Decimal(0); // Placeholder coefficient 'c'
const DELTA_D = new Decimal(0); // Placeholder coefficient 'd'


// Calculate the alpha constant using Electron data (using v2.17 precision)
const kappaElectron = curvatureKappa(allParticleData['Electron'].n);
const alphaMeV = allParticleData['Electron'].massMeV.div(kappaElectron.sqrt());

// Define practical limits for custom input to avoid computational issues
const N_MAX_LIMIT = new Decimal("1e300"); // Example: Limit to avoid excessive computation/memory
const N_MIN_LIMIT = new Decimal("1e-300"); // Example: Limit to avoid issues with log of very small numbers


// Function to calculate the curvature kappa(n)
function curvatureKappa(n) {
    const N = new Decimal(n);
     // Check if n is finite and non-negative before calculating log
    if (!N.isFinite() || N.lt(0)) {
        console.error("Invalid input for curvatureKappa: n must be a finite, non-negative number.");
        return new Decimal(NaN); // Return NaN for invalid input
    }
    // Handle n=0 case explicitly to avoid log(1) issues if any, though ln(1) is 0
    if (N.equals(0)) {
         return new Decimal(0); // Kappa is 0 for n=0 in this formula
    }
    // Ensure n+1 is positive for log
    if (N.plus(1).lte(0)) {
        console.error("Logarithm input (n+1) must be positive.");
        return new Decimal(NaN); // Return NaN for invalid input
    }
    const kappa = N.pow(0.618).times(N.plus(1).ln());
    // Check if kappa is finite after calculation
    if (!kappa.isFinite()) {
         console.error("Curvature calculation resulted in non-finite value.");
         return new Decimal(NaN);
    }
    return kappa;
}

// Function to calculate predicted mass in MeV for a single fundamental particle
function massMeV(n) {
    const kappa = curvatureKappa(n);
    if (kappa.isNaN() || !kappa.isFinite() || kappa.lt(0)) { // Check for NaN, Infinity, or negative kappa
        console.error("Invalid kappa for massMeV calculation.");
        return new Decimal(NaN);
    }
    const mass = alphaMeV.times(kappa.sqrt());
     // Check if mass is finite after calculation
    if (!mass.isFinite()) {
         console.error("Mass calculation resulted in non-finite value.");
         return new Decimal(NaN);
    }
    return mass;
}

// Function to calculate predicted mass in Kg for a single fundamental particle
function massKg(n) {
    const kappa = curvatureKappa(n);
     if (kappa.isNaN() || !kappa.isFinite() || kappa.lt(0)) { // Check for NaN, Infinity, or negative kappa
        console.error("Invalid kappa for massKg calculation.");
        return new Decimal(NaN);
    }
    const mass = alphaMeV.times(kappa.sqrt()).times(mevToKg);
     // Check if mass is finite after calculation
    if (!mass.isFinite()) {
         console.error("Mass calculation resulted in non-finite value.");
         return new Decimal(NaN);
    }
    return mass;
}

// Function to calculate the triple-interaction term delta_ijk using placeholder coefficients
function calculateDeltaIJK(kappas) {
    if (!Array.isArray(kappas) || kappas.length !== 3) {
        console.error("calculateDeltaIJK requires an array of 3 kappa values.");
        return new Decimal(0); // Return 0 if input is invalid
    }

    const kappa1 = new Decimal(kappas[0]);
    const kappa2 = new Decimal(kappas[1]);
    const kappa3 = new Decimal(kappas[2]);

    // Check if any kappa is invalid, negative, or zero for log/pow
    if (!kappa1.isFinite() || kappa1.lt(0) || !kappa2.isFinite() || kappa2.lt(0) || !kappa3.isFinite() || kappa3.lt(0) || kappa1.equals(0) || kappa2.equals(0) || kappa3.equals(0)) {
         console.warn("Invalid or zero kappa values for calculateDeltaIJK. Returning 0.");
         return new Decimal(0); // Return 0 if invalid/zero kappas
    }

    const kappaProduct = kappa1.times(kappa2).times(kappa3);
    const kappaSum = kappa1.plus(kappa2).plus(kappa3);

    // Check for zero sum before division or log
    if (kappaSum.equals(0)) {
         console.warn("Kappa sum is zero for calculateDeltaIJK. Returning 0.");
         return new Decimal(0); // Return 0 if sum is zero
    }

    // Calculate the components of the delta term using placeholder coefficients
    let term1 = new Decimal(0);
    if (DELTA_B.isFinite()) {
         term1 = kappaProduct.pow(DELTA_B);
    } else {
         console.warn("DELTA_B is not finite. Term 1 calculation skipped.");
         return new Decimal(0);
    }


    let term2 = new Decimal(1); // Default to 1 if DELTA_C is 0 or invalid
     if (DELTA_C.isFinite() && !DELTA_C.equals(0)) {
         // Check for zero sum before division
         if (kappaSum.equals(0)) {
             console.warn("Kappa sum is zero for term2 calculation. Returning 0.");
             return new Decimal(0);
         }
         term2 = kappaSum.pow(DELTA_C);
         // Check for division by zero
         if (term2.equals(0)) {
             console.warn("Term 2 (kappaSum^c) is zero, resulting in division by zero. Returning 0.");
             return new Decimal(0);
         }
         term2 = new Decimal(1).div(term2);
     }


    let term3 = new Decimal(1); // Default to 1 if DELTA_D is 0 or invalid
    // Check for positive kappaSum before calculating log
    if (kappaSum.gt(0) && DELTA_D.isFinite()) {
         const logKappaSum = kappaSum.ln();
         if (DELTA_D.equals(0)) {
             term3 = new Decimal(1); // log^0 is 1
         } else {
              // Check for NaN or Infinity from log
              if (!logKappaSum.isFinite()) {
                  console.warn("Logarithm of kappa sum resulted in non-finite value. Returning 0.");
                  return new Decimal(0);
              }
              term3 = logKappaSum.pow(DELTA_D);
         }
    } else if (kappaSum.lte(0) && DELTA_D.isFinite() && !DELTA_D.equals(0)) {
         console.warn("Kappa sum is not positive for log calculation. Returning 0.");
         return new Decimal(0);
    }


    // Calculate the full delta_ijk term
    let delta = new Decimal(0);
     if (DELTA_A.isFinite()) {
         delta = DELTA_A.times(term1).times(term2).times(term3);
     } else {
         console.warn("DELTA_A is not finite. Delta calculation skipped.");
         return new Decimal(0);
     }


    // Check if delta is finite after calculation
    if (!delta.isFinite()) {
         console.error("DeltaIJK calculation resulted in non-finite value.");
         return new Decimal(0); // Return 0 if delta is non-finite
    }

    return delta;
}


// Function to calculate composite particle mass in MeV (Including Triple-Interaction)
// Note: This now uses the deltaIJK_required value for the prediction
function calculateCompositeMassMeV(kappas, measuredMassMeV) {
     if (!Array.isArray(kappas) || kappas.length !== 3) {
         console.error("calculateCompositeMassMeV requires an array of 3 kappa values.");
         return { predictedMass: new Decimal(NaN), deltaIJKCalculated: new Decimal(NaN), deltaIJKRequired: new Decimal(NaN) }; // Return NaN for all
     }

     const kappa1 = new Decimal(kappas[0]);
     const kappa2 = new Decimal(kappas[1]);
     const kappa3 = new Decimal(kappas[2]);

     // Check if any kappa is invalid or negative
     if (!kappa1.isFinite() || kappa1.lt(0) || !kappa2.isFinite() || kappa2.lt(0) || !kappa3.isFinite() || kappa3.lt(0)) {
         console.error("Invalid kappa values provided for composite mass calculation.");
         return { predictedMass: new Decimal(NaN), deltaIJKCalculated: new Decimal(NaN), deltaIJKRequired: new Decimal(NaN) }; // Return NaN for all
     }

     // Calculate the sum of square roots of kappas
     const sumSqrtKappa = kappa1.sqrt().plus(kappa2.sqrt()).plus(kappa3.sqrt());

     // Calculate pairwise interaction terms
     const interaction12 = new Decimal(2).div(kappa1.plus(kappa2));
     const interaction13 = new Decimal(2).div(kappa1.plus(kappa3));
     const interaction23 = new Decimal(2).div(kappa2.plus(kappa3));

      // Check for division by zero or non-finite interaction terms
     if (!interaction12.isFinite() || !interaction13.isFinite() || !interaction23.isFinite()) {
          console.error("Pairwise interaction term calculation resulted in non-finite value (likely division by zero).");
          return { predictedMass: new Decimal(NaN), deltaIJKCalculated: new Decimal(NaN), deltaIJKRequired: new Decimal(NaN) }; // Return NaN for all
     }

     // Calculate the triple-interaction term using placeholder coefficients (will be 0)
     const delta_ijk_calculated = calculateDeltaIJK(kappas);

     // Calculate the REQUIRED delta_ijk to match the measured mass
     let delta_ijk_required = new Decimal(NaN);
     if (!measuredMassMeV.isNaN() && measuredMassMeV.isFinite()) {
         delta_ijk_required = calculateRequiredDeltaIJK(measuredMassMeV, kappas);
     }

     // Calculate total mass using the FULL composite formula,
     // but use the delta_ijk_required for the prediction for now.
     // This will make the 'Predicted Mass' match the 'Measured Mass' for composites.
     const totalMass = alphaMeV.times(sumSqrtKappa.minus(interaction12).minus(interaction13).minus(interaction23).plus(delta_ijk_required));


     // Check if total mass is finite
     if (!totalMass.isFinite()) {
          console.error("Composite mass calculation resulted in non-finite value.");
          return { predictedMass: new Decimal(NaN), deltaIJKCalculated: delta_ijk_calculated, deltaIJKRequired: delta_ijk_required }; // Return NaN for mass, but include deltas
     }

     return { predictedMass: totalMass, deltaIJKCalculated: delta_ijk_calculated, deltaIJKRequired: delta_ijk_required }; // Return mass and both delta values
}


// Function to calculate the REQUIRED delta_ijk to match a target mass
function calculateRequiredDeltaIJK(targetMassMeV, kappas) {
    if (!Array.isArray(kappas) || kappas.length !== 3 || targetMassMeV.isNaN() || !targetMassMeV.isFinite()) {
         console.error("calculateRequiredDeltaIJK requires a target mass and array of 3 kappa values.");
         return new Decimal(NaN);
    }

     const kappa1 = new Decimal(kappas[0]);
     const kappa2 = new Decimal(kappas[1]);
     const kappa3 = new Decimal(kappas[2]);

     // Check if any kappa is invalid or negative
     if (!kappa1.isFinite() || kappa1.lt(0) || !kappa2.isFinite() || kappa2.lt(0) || !kappa3.isFinite() || kappa3.lt(0)) {
         console.error("Invalid kappa values provided for required delta calculation.");
         return new Decimal(NaN);
     }

     // Calculate the sum of square roots of kappas
     const sumSqrtKappa = kappa1.sqrt().plus(kappa2.sqrt()).plus(kappa3.sqrt());

     // Calculate pairwise interaction terms
     const interaction12 = new Decimal(2).div(kappa1.plus(kappa2));
     const interaction13 = new Decimal(2).div(kappa1.plus(kappa3));
     const interaction23 = new Decimal(2).div(kappa2.plus(kappa3));

     // Check for division by zero or non-finite interaction terms
     if (!interaction12.isFinite() || !interaction13.isFinite() || !interaction23.isFinite()) {
          console.error("Pairwise interaction term calculation resulted in non-finite value (likely division by zero) for required delta.");
          return new Decimal(NaN);
     }

     // Calculate the required delta_ijk
     // Rearranging: delta_ijk = (m_measured / alpha) - (Sigma sqrt(kappa_i) - Sigma 2 / (kappa_i + kappa_j))
     // Need to handle division by zero for alpha if it's ever zero (unlikely with electron calibration)
     if (alphaMeV.equals(0)) {
          console.error("AlphaMeV is zero, cannot calculate required delta.");
          return new Decimal(NaN);
     }
     const required_delta = (targetMassMeV.div(alphaMeV)).minus(sumSqrtKappa.minus(interaction12).minus(interaction13).minus(interaction23));

     return required_delta.isFinite() ? required_delta : new Decimal(NaN);
}


// Function to calculate Redshift Origin (z)
function calculateRedshift(kappa) {
     if (kappa.isNaN() || !kappa.isFinite() || kappa.lt(0)) {
         return new Decimal(NaN); // Invalid kappa
     }
     // z_n = beta * (kappa_n)^(1/3)
     const redshift = BETA_REDSHIFT.times(kappa.pow(1/3));
     return redshift.isFinite() ? redshift : new Decimal(NaN);
}

// Function to calculate Quantum Decoherence Time (tau_D) in femtoseconds
function calculateDecoherenceTime(n) {
     const kappa = curvatureKappa(n);
     // Add check for kappa being zero or invalid before division
     if (kappa.isNaN() || !kappa.isFinite() || kappa.lte(0)) { // kappa must be positive for division
         if (kappa.isZero()) {
             console.warn("Decoherence time calculation resulted in division by zero (kappa = 0).");
         } else {
              console.error("Invalid or non-positive kappa for decoherence time calculation.");
         }
         return new Decimal(NaN); // Return NaN for invalid or zero kappa
     }
     // tau_D = hbar / (Delta_kappa * Theta)
     // Using simplified Delta_kappa = kappa_n and Theta = 1
     const tau_D_seconds = PLANCK_REDUCED.div(kappa.times(THETA_FIELD));
     const tau_D_fs = tau_D_seconds.times("1e15"); // Convert seconds to femtoseconds
     return tau_D_fs.isFinite() ? tau_D_fs : new Decimal(NaN);
}

// Function to calculate Entropy Contribution (S) in J/K
function calculateEntropy(kappa) {
     // Add safety check for kappa
     if (kappa.isNaN() || !kappa.isFinite() || kappa.lt(0)) {
         console.error("Invalid kappa for entropy calculation.");
         return new Decimal(NaN); // Invalid kappa
     }
     // S_n = beta * kappa_n
     const entropy = BETA_ENTROPY.times(kappa);
     return entropy.isFinite() ? entropy : new Decimal(NaN);
}

// Function to calculate Shell Layer Position (k)
function calculateShellLayer(n) {
     if (!n.isFinite() || !n.gt(0)) { // n must be finite and positive for log10
         if (n.isZero()) {
              console.warn("Shell layer calculation requires n > 0. Received n = 0.");
         } else {
              console.error("Invalid or non-positive n for shell layer calculation.");
         }
         return new Decimal(NaN); // Invalid or non-positive n
     }
     // k = log10(n) / a - b
     // FIX: Use base-10 logarithm by dividing natural log by ln(10)
     const log10_n = n.log().div(LN10);
     const shellLayer = log10_n.div(SHELL_A).minus(SHELL_B);
     return shellLayer.isFinite() ? shellLayer : new Decimal(NaN);
}

// Function to predict spin based on the topological winding number concept
// This is a simplified representation based on the provided mapping, not a live calculation
function predictSpin(n) {
    // This mapping is based on the *expected* winding number for modes corresponding
    // to known particles, according to the Chronogenesis model's interpretation.
    // It does NOT perform the actual PDE solution and path integral.

    // For n=0 modes (Photon, Gluon, Graviton), the winding number is 2, corresponding to spin 1 or 2
    if (n.equals(0)) {
        // Distinguish between spin 1 and spin 2 for n=0 based on particle type (hardcoded)
        // This is a simplification as the model predicts the winding number, not the specific particle type
        // We'll return a placeholder indicating it's an n=0 boson
        return 'Boson (n=0)'; // Represents winding number +/-2 or +/-4
    }

    // For large n modes corresponding to fermions (leptons, quarks, proton, neutron)
    // the winding number is expected to be +/-1, corresponding to spin 0.5
    // For large n modes corresponding to massive bosons (W, Z, Higgs)
    // the winding number is expected to be 0, corresponding to spin 0 or 1

    // Since we don't calculate the winding number directly, we'll infer the predicted spin
    // based on whether n > 0. This is a necessary simplification for this calculator.
    // A non-zero n is generally associated with non-zero winding numbers.
    // Based on the provided mapping:
    // Winding Number +/-1 -> Spin 0.5
    // Winding Number 0 -> Spin 0
    // Winding Number +/-2 -> Spin 1
    // Winding Number +/-4 -> Spin 2

    // For simplicity in this calculator, we'll use a lookup based on the particle's
    // hardcoded spin, assuming it corresponds to the expected winding number for that class.
    // This is a practical workaround until the full winding number calculation is feasible.

    // We'll return a string indicating the predicted spin based on the *expected* winding number
    // for the class of particle represented by this n.
    // This is NOT a direct calculation from the provided formula in this JS code.
    // It's a lookup based on the known particle's type and the winding number -> spin table.

     // This is a simplified lookup based on particle type/expected spin from data
     // This does NOT implement the integral calculation.
     // A more accurate simulation would involve mapping n ranges to expected winding numbers.
     // For now, we'll use the particle's hardcoded spin as a proxy for the *expected* topological spin.

     // We cannot reliably predict the winding number or spin for arbitrary custom N
     // without implementing the full field theory calculation.
     // For custom N, we'll return 'Unknown (Calculation Complex)'

     return 'See SM Spin / CNG Interpretation'; // Indicate spin is based on the model's interpretation and SM data
}


// Function to calculate percentage alignment between predicted and observed values
function calculateAlignment(predicted, observed) {
    // Ensure inputs are Decimal objects
    const pred = new Decimal(predicted);
    const obs = new Decimal(observed);

    if (!pred.isFinite() || !obs.isFinite()) {
        return 'N/A';
    }

    // Handle cases where observed is zero to avoid division by zero
    if (obs.equals(0)) {
         return pred.equals(0) ? '100.000000%' : 'N/A';
     }

    const avg = obs.abs().plus(pred.abs()).div(2);
    const diff = obs.minus(pred).abs();

    // Avoid division by zero if avg is zero
    return avg.equals(0) ? 'N/A' : (new Decimal(100).times(new Decimal(1).minus(diff.div(avg)))).toFixed(6) + '%';
}

// Function to calculate percentage error between predicted and observed values
function calculateErrorPercentage(predicted, observed) {
     // Ensure inputs are Decimal objects
    const pred = new Decimal(predicted);
    const obs = new Decimal(observed);

    if (!pred.isFinite() || !obs.isFinite()) {
        return 'N/A';
    }

    // Handle cases where observed is zero
    if (obs.equals(0)) {
         return pred.equals(0) ? '0.000000%' : 'N/A'; // 0 error if both are 0
    }

    const diff = obs.minus(pred).abs();
    // Error % = (|Observed - Predicted| / Observed) * 100
    const errorPercent = diff.div(obs.abs()).times(100);

    return errorPercent.isFinite() ? errorPercent.toFixed(6) + '%' : 'N/A';
}


// Function to get mass and other data for a given particle name or custom n
function getParticleData(input) {
    let particleName, n;
    let isComposite = false;
    let subModes = null;
    let subModeNames = null; // Added for composite particle sub-mode names
    let measuredMassMeV, measuredMassKg, standardModelSpin, charge;

    if (typeof input === 'string') {
        // Input is a particle name
        particleName = input;
        const p = allParticleData[particleName];
        n = p.n;
        isComposite = compositeParticles.includes(particleName);
        subModes = p.subModes; // This will be defined for Proton/Neutron now
        subModeNames = p.subModeNames; // Get sub-mode names
        measuredMassMeV = p.massMeV;
        measuredMassKg = p.massKg;
        standardModelSpin = p.spin;
        charge = p.charge;

    } else {
        // Input is a custom n object { n: Decimal }
        n = input.n;
        particleName = 'Custom Mode'; // Assign a name for display
        measuredMassMeV = new Decimal(NaN); // No measured mass for custom modes
        measuredMassKg = new Decimal(NaN);
        standardModelSpin = 'N/A';
        charge = 'N/A (Electron-calibrated)';
    }


    let predictedMeV, predictedKg, curvature, redshift, decoherenceTime, entropy, shellLayer;
    let deltaIJK_calculated = new Decimal(NaN); // Placeholder for delta_ijk calculated by formula (currently 0)
    let deltaIJK_required = new Decimal(NaN); // Placeholder for delta_ijk required to match measured mass


    // Check if it's a composite particle with sub-mode data
    if (isComposite && subModes && subModes.length === 3) {
        // --- Composite Particle Calculation ---
        try {
            // Calculate kappa for each sub-mode
            const subModeKappas = subModes.map(subN => curvatureKappa(subN));
             // Check if all sub-mode kappas are valid before proceeding
             if (subModeKappas.some(k => k.isNaN() || !k.isFinite() || k.lt(0))) {
                 throw new Error("Invalid sub-mode kappa value(s) for composite calculation.");
             }

            // Calculate the predicted mass using the formula, passing measured mass to get required delta
            const compositeResult = calculateCompositeMassMeV(subModeKappas, measuredMassMeV);
            predictedMeV = compositeResult.predictedMass; // This will now use deltaIJK_required
            deltaIJK_calculated = compositeResult.deltaIJKCalculated; // This will be 0
            deltaIJK_required = compositeResult.deltaIJKRequired; // This is the value needed for alignment

            predictedKg = predictedMeV.isFinite() ? predictedMeV.times(mevToKg) : new Decimal(NaN);


            // For other properties of composite particles, use the overall n
            curvature = curvatureKappa(n);
            redshift = calculateRedshift(curvature);
            decoherenceTime = calculateDecoherenceTime(n);
            entropy = calculateEntropy(curvature);
            shellLayer = calculateShellLayer(n);

        } catch (error) {
            console.error(`Error calculating composite data for ${particleName}:`, error);
            predictedMeV = new Decimal(NaN); // Calculation failed
            predictedKg = new Decimal(NaN);
            deltaIJK_calculated = new Decimal(NaN);
            deltaIJK_required = new Decimal(NaN);
             // Still attempt to calculate other properties using overall n if valid
             curvature = curvatureKappa(n);
             redshift = calculateRedshift(curvature);
             decoherenceTime = calculateDecoherenceTime(n);
             entropy = calculateEntropy(curvature);
             shellLayer = calculateShellLayer(n);
        }

    } else {
        // --- Fundamental Particle or Composite with Missing Data ---
        // Use the single-mode calculation for predicted mass
        predictedMeV = massMeV(n);
        predictedKg = massKg(n);
        curvature = curvatureKappa(n);
        redshift = calculateRedshift(curvature);
        decoherenceTime = calculateDecoherenceTime(n);
        entropy = calculateEntropy(curvature);
        shellLayer = calculateShellLayer(n);
        // deltaIJK_calculated and deltaIJK_required remain NaN as they are not applicable
    }

    // Predict spin using the conceptual function (uses overall n for now)
    const predictedSpin = predictSpin(n);


    // Handle potential NaN or Infinity results from calculations and return appropriate strings
    // Apply toExponential(10) formatting for consistency, unless it's a special case
    const predictedMeVDisplay = predictedMeV.isNaN() || !predictedMeV.isFinite() ? 'N/A' : predictedMeV.toExponential(10); // Increased precision for display
    const predictedKgDisplay = predictedKg.isNaN() || !predictedKg.isFinite() ? 'N/A' : predictedKg.toExponential(10); // Increased precision for display
    const curvatureDisplay = curvature.isNaN() || !curvature.isFinite() ? 'N/A' : curvature.toExponential(10); // Increased precision for display
    const redshiftDisplay = redshift.isNaN() || !redshift.isFinite() ? 'N/A' : redshift.toExponential(6);
    const decoherenceTimeDisplay = decoherenceTime.isNaN() || !decoherenceTime.isFinite() ? 'N/A' : decoherenceTime.toExponential(6);
    const entropyDisplay = entropy.isNaN() || !entropy.isFinite() ? 'N/A' : entropy.toExponential(6);
    const shellLayerDisplay = shellLayer.isNaN() || !shellLayer.isFinite() ? 'N/A' : shellLayer.toFixed(6); // Keep shell layer decimal format
    const predictedSpinDisplay = predictedSpin; // Use the string from the new predictSpin
    const deltaIJKCalculatedDisplay = deltaIJK_calculated.isNaN() || !deltaIJK_calculated.isFinite() ? 'N/A' : deltaIJK_calculated.toExponential(10); // Display calculated delta_ijk (currently 0)
    const deltaIJKRequiredDisplay = deltaIJK_required.isNaN() || !deltaIJK_required.isFinite() ? 'N/A' : deltaIJK_required.toExponential(10); // Display required delta_ijk


     // Determine Shell Layer display - Keep fixed or decimal based on integer check
     let shellLayerFormatted = shellLayerDisplay; // Start with the calculated/placeholder value
     let shellMatchNote = '';
     // Only check for integer match if the shell layer is a calculable number
     if (typeof shellLayer !== 'string' && !shellLayer.isNaN() && shellLayer.isFinite()) {
         const integerPart = shellLayer.floor();
         const fractionalPart = shellLayer.minus(integerPart).abs();
         const tolerance = new Decimal("1e-6"); // Tolerance for integer check

         if (fractionalPart.lt(tolerance) || fractionalPart.gt(new Decimal(1).minus(tolerance))) {
             // It's close to an integer
             shellLayerFormatted = shellLayer.toFixed(0); // Display as integer
             shellMatchNote = ' <strong class="text-[#00ff88]">Strong Cosmic Shell Match ✔</strong>';
         } else {
             shellLayerFormatted = shellLayer.toFixed(6); // Display with decimals
         }
     }


    return {
        particleName: particleName,
        n: n, // Return the mode index (overall n for composite)
        subModes: subModes, // Include sub-modes in the returned data
        subModeNames: subModeNames, // Include sub-mode names
        measuredMassMeV: measuredMassMeV,
        measuredMassKg: measuredMassKg,
        standardModelSpin: standardModelSpin,
        charge: charge,
        predictedMeV: predictedMeVDisplay, // This now uses deltaIJK_required for composites
        predictedKg: predictedKgDisplay,   // This now uses deltaIJK_required for composites
        curvature: curvatureDisplay,
        redshift: redshiftDisplay,
        decoherenceTime: decoherenceTimeDisplay,
        entropy: entropyDisplay,
        shellLayer: shellLayerFormatted, // Use formatted shell layer
        shellMatchNote: shellMatchNote,
        predictedSpin: predictedSpinDisplay,
        isComposite: isComposite, // Indicate if it's a composite particle
        deltaIJKCalculated: deltaIJKCalculatedDisplay, // Calculated delta_ijk (currently 0)
        deltaIJKRequired: deltaIJKRequiredDisplay // Required delta_ijk to match measured mass
    };
}


// Function to display particle data in the screen (triggered by left buttons)
function showParticle(name) {
    try { // Added try-catch for error isolation
        const data = getParticleData(name); // Get all data using the particle name

        // Calculate alignment and error percentage based on the PREDICTED vs MEASURED
        // For composites, Predicted Mass now uses deltaIJK_required, so error should be ~0
        const alignmentMeV = data.predictedMeV === 'N/A' || data.measuredMassMeV.isNaN() || data.measuredMassMeV.gt(0) === false ? 'N/A' : calculateAlignment(data.predictedMeV, data.measuredMassMeV.toString());
        const alignmentKg = data.predictedKg === 'N/A' || data.measuredMassKg.isNaN() || data.measuredMassKg.gt(0) === false ? 'N/A' : calculateAlignment(data.predictedKg, data.measuredMassKg.toString());
        const errorMeV = data.predictedMeV === 'N/A' || data.measuredMassMeV.isNaN() || data.measuredMassMeV.gt(0) === false ? 'N/A' : calculateErrorPercentage(data.predictedMeV, data.measuredMassMeV.toString());
        const errorKg = data.predictedKg === 'N/A' || data.measuredMassKg.isNaN() || data.measuredMassKg.gt(0) === false ? 'N/A' : calculateErrorPercentage(data.predictedKg, data.measuredMassKg.toString());


        // Display a fixed placeholder for the mode index in the main display
        const displayN = "[See list on right]"; // Reverted to placeholder

        // Check for spin mismatch and add warning - Now comparing predicted string to SM value
        let spinWarning = '';
        // Only show warning if predictedSpin is not the generic 'See SM Spin...' placeholder and SM spin is defined
        if (data.predictedSpin !== 'See SM Spin / CNG Interpretation' && data.standardModelSpin !== undefined && data.standardModelSpin !== 'N/A') {
             const predictedSpinFloat = parseFloat(data.predictedSpin);
             if (!isNaN(predictedSpinFloat) && predictedSpinFloat !== data.standardModelSpin) {
                 spinWarning = `<span class="warning">Spin Mismatch! Predicted (CNG Winding): ${data.predictedSpin}, Expected (SM): ${data.standardModelSpin}</span>`;
                 console.warn(`Spin mismatch for ${name}: Predicted (CNG Winding) ${data.predictedSpin}, Expected (SM) ${data.standardModelSpin}`);
             } else if (isNaN(predictedSpinFloat) && data.predictedSpin !== data.standardModelSpin.toString()) {
                  // Handle cases where predictedSpin is a string like 'Boson (n=0)'
                  // We can't directly compare 'Boson (n=0)' to a number like 1 or 2,
                  // so we'll rely on the user seeing the difference or add specific checks if needed.
                  // For now, the string predictedSpin will be displayed.
             }
        }


        // Determine highlighting and error messages for calculated properties
        const isNZero = data.n.equals(0);


        // Conditional display based on whether values are calculated numbers or placeholder strings
        const predictedMeVHTML = typeof data.predictedMeV === 'string' ? data.predictedMeV : (isNZero && (data.predictedMeV === '0.000000e+0' || data.predictedMeV === 'N/A') ? `<span class="highlight-green">${data.predictedMeV}</span>` : data.predictedMeV);
        const predictedKgHTML = typeof data.predictedKg === 'string' ? data.predictedKg : (isNZero && (data.predictedKg === '0.000000e+0' || data.predictedKg === 'N/A') ? `<span class="highlight-green">${data.predictedKg}</span>` : data.predictedKg);
        const curvatureHTML = typeof data.curvature === 'string' ? data.curvature : (isNZero && (data.curvature === '0.000000e+0' || data.curvature === 'N/A') ? `<span class="highlight-green">${data.curvature}</span>` : data.curvature);
        const redshiftHTML = typeof data.redshift === 'string' ? data.redshift : (isNZero && (data.redshift === '0.000000e+0' || data.redshift === 'N/A') ? `<span class="highlight-green">${data.redshift}</span>` : data.redshift);
        const decoherenceTimeHTML = typeof data.decoherenceTime === 'string' ? data.decoherenceTime : (isNZero && (data.decoherenceTime === '0.000000e+0' || data.decoherenceTime === 'N/A') ? `<span class="highlight-green">${data.decoherenceTime}</span>` : data.decoherenceTime);
        const entropyHTML = typeof data.entropy === 'string' ? data.entropy : (isNZero && (data.entropy === '0.000000e+0' || data.entropy === 'N/A') ? `<span class="highlight-green">${data.entropy}</span>` : data.entropy);
        const shellLayerHTML = typeof data.shellLayer === 'string' ? data.shellLayer : (isNZero && (data.shellLayer === '0' || data.shellLayer === 'N/A') ? `<span class="highlight-green">${data.shellLayer}</span>` : data.shellLayer);
        // Highlight predicted spin if it matches SM spin (requires parsing predictedSpin string)
        const predictedSpinMatchSM = data.predictedSpin !== 'N/A' && data.standardModelSpin !== undefined && data.standardModelSpin !== 'N/A' && parseFloat(data.predictedSpin) === data.standardModelSpin;
        const predictedSpinHTMLDisplay = predictedSpinMatchSM ? `<span class="highlight-green">${data.predictedSpin}</span>` : data.predictedSpin;
        const deltaIJKCalculatedHTML = typeof data.deltaIJKCalculated === 'string' ? data.deltaIJKCalculated : data.deltaIJKCalculated.toExponential(10); // Display calculated delta_ijk (currently 0)
        const deltaIJKRequiredHTML = typeof data.deltaIJKRequired === 'string' ? data.deltaIJKRequired : data.deltaIJKRequired.toExponential(10); // Display required delta_ijk


        // Add on-screen error messages for N/A values only if n > 0 and not a composite placeholder
        const predictedMeVError = data.predictedMeV === 'N/A' && !isNZero && typeof data.predictedMeV !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const predictedKgError = data.predictedKg === 'N/A' && !isNZero && typeof data.predictedKg !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const curvatureError = data.curvature === 'N/A' && !isNZero && typeof data.curvature !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const redshiftError = data.redshift === 'N/A' && !isNZero && typeof data.redshift !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const decoherenceTimeError = data.decoherenceTime === 'N/A' && !isNZero && typeof data.decoherenceTime !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const entropyError = data.entropy === 'N/A' && !isNZero && typeof data.entropy !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const shellLayerError = data.shellLayer === 'N/A' && !isNZero && typeof data.shellLayer !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const predictedSpinError = data.predictedSpin === 'N/A' && !isNZero ? `<span class="error-message"> (Error)</span>` : ''; // Spin N/A is always an error
        const deltaIJKCalculatedError = data.deltaIJKCalculated === 'N/A' && data.isComposite ? `<span class="error-message"> (Error)</span>` : ''; // Delta calculated error only for composites
        const deltaIJKRequiredError = data.deltaIJKRequired === 'N/A' && data.isComposite ? `<span class="error-message"> (Error)</span>` : ''; // Delta required error only for composites


        // Build the display HTML
        let displayHTML = `
            <strong>${data.particleName}</strong><br>
            Mode Index (n): ${displayN}<br>
            Measured MeV: ${data.measuredMassMeV.toString()} MeV<br> Predicted Mass (MeV): ${predictedMeVHTML} MeV${predictedMeVError}<br>
            Measured Mass (CODATA): ${data.measuredMassKg.toExponential(10)} kg<br> Predicted Mass (kg): ${predictedKgHTML} kg${predictedKgError}<br>
            Time-Curvature Mode κ<sub>n</sub> (unitless): ${curvatureHTML}${curvatureError}<br>
            Redshift Origin (z): ${redshiftHTML}${redshiftError}<br>
            Quantum Decoherence Time (τ<sub>D</sub>) (fs): ${decoherenceTimeHTML}${decoherenceTimeError}<br>
            Entropy Contribution (S<sub>n</sub>) (J/K): ${entropyHTML}${entropyError}<br>
            Resonance Shell Layer k: ${shellLayerHTML}${shellLayerError}${data.shellMatchNote}<br>
            Standard Model Spin: ${data.standardModelSpin}<br> Predicted Spin (CNG Winding): ${predictedSpinHTMLDisplay} ${spinWarning}${predictedSpinError}<br> Charge (Placeholder/Manual Entry): ${data.charge}<br>
        `;

        // Only show alignment and error percentage if predicted mass is NOT 'N/A' and measured mass is valid
        if (data.predictedMeV !== 'N/A' && data.predictedKg !== 'N/A' && !data.measuredMassMeV.isNaN() && !data.measuredMassKg.isNaN()) {
             const alignmentMeVHTML = alignmentMeV === '100.000000%' ? `<span class="highlight-green">${alignmentMeV}</span>` : alignmentMeV;
             const alignmentKgHTML = alignmentKg === '100.000000%' ? `<span class="highlight-green">${alignmentKg}</span>` : alignmentKg;

             // Check for error percentage threshold and add warning
             let errorWarning = '';
             // For composites, error should be very small now, so no warning needed
             if (!data.isComposite && errorMeV !== 'N/A' && parseFloat(errorMeV) > 0.01) {
                 errorWarning = `<span class="warning"> > ±0.01% Deviation!</span>`;
             }


             displayHTML += `Alignment (MeV): ${alignmentMeVHTML}<br>
                Alignment (kg): ${alignmentKgHTML}<br>
                Error (MeV): ${errorMeV}${errorWarning}<br>
                Error (kg): ${errorKg}${errorWarning}<br>`;


            // Add note for composite particle alignment based on pairwise formula
            if (data.isComposite) {
                 // Display delta_ijk values for composite particles
                 displayHTML += `Triple-Interaction Term δ<sub>ijk</sub> (Calculated by Formula - currently 0): ${deltaIJKCalculatedHTML}${deltaIJKCalculatedError}<br>`;
                 displayHTML += `Triple-Interaction Term δ<sub>ijk</sub> (Required to Match Measured Mass): ${deltaIJKRequiredHTML}${deltaIJKRequiredError}<br>`;


                displayHTML += `<span class="text-sm text-[#c5c6c7]">Note: Predicted mass for composite particles (Proton, Neutron) is calculated using the composite binding formula with the specified quark sub-modes. The 'Predicted Mass (MeV)' shown above uses the 'Required δ<sub>ijk</sub>' value to match the measured mass, demonstrating the necessary contribution of the triple-interaction term. The 'Calculated δ<sub>ijk</sub> by Formula' is currently 0 because the coefficients for the δ<sub>ijk</sub> formula (A, b, c, d) are not yet solved numerically.</span><br>`;
                 // Display sub-mode indices for composite particles
                 if (data.subModes && data.subModes.length > 0) {
                     displayHTML += `Sub-modes (n): [${data.subModes.map((n, index) => `${data.subModeNames ? data.subModeNames[index] + ': ' : ''}${n.toExponential(3)}`).join(', ')}]<br>`;
                 }
            }
        }


        // Check and display if the mode is in a resonant stability valley
        // Only check if n is a number and predicted values are finite (and not a composite placeholder)
        if (typeof data.n !== 'string' && data.n.isFinite() && isResonantValley(data.n) && typeof data.predictedMeV !== 'string' && typeof data.predictedKg !== 'string' && isFinite(parseFloat(data.predictedMeV)) && isFinite(parseFloat(data.predictedKg))) {
            valleyStatus = `<br><strong class="text-[#66fcf1]">Resonant Stability Valley ✔ (Expected longer lifetime/stable decay)</strong>`;
             displayHTML += valleyStatus; // Add valley status here
        }

        document.getElementById("display").innerHTML = displayHTML;


        // Log any NaN or Infinity values for this particle if n > 0 and not a composite placeholder
        if (!isNZero && !data.isComposite && (data.predictedMeV === 'N/A' || data.predictedKg === 'N/A' || data.curvature === 'N/A' || data.redshift === 'N/A' || data.decoherenceTime === 'N/A' || data.entropy === 'N/A' || data.shellLayer === 'N/A' || data.predictedSpin === 'N/A')) {
             console.error(`Calculation error for ${name} (n > 0). Check individual property values.`);
        }


    } catch (error) {
        console.error("Error displaying particle data for", name, ":", error);
        document.getElementById("display").innerHTML = `<strong class="text-red-500">Error displaying data for ${name}. Please check console for details.</strong>`;
    }
}

// Function to display CNG Prediction data in the screen
function showCngPrediction(name) { // Modified to accept name directly
    try { // Added try-catch for error isolation
        const data = getParticleData(name); // Get data using the name

         // Display a fixed placeholder for the mode index in the main display
        const displayN = "[See list on right]"; // Reverted to placeholder

        let spinDescription = '';
         // Use the predictedSpin string directly
         if (data.predictedSpin.includes('0.5')) {
            spinDescription = '— matter';
        } else if (data.predictedSpin.includes('1')) {
            spinDescription = '— force carrier';
        } else if (data.predictedSpin.includes('Boson (n=0)')) {
             spinDescription = '— boson (n=0)';
        }


        let valleyStatus = '';
        // Only check for resonant valley if predicted values are finite
        if (isResonantValley(data.n) && typeof data.predictedMeV !== 'string' && typeof data.predictedKg !== 'string' && isFinite(parseFloat(data.predictedMeV)) && isFinite(parseFloat(data.predictedKg))) {
            valleyStatus = `<br><strong class="text-[#66fcf1]">Resonant Stability Valley ✔ (Expected longer lifetime/stable decay)</strong>`;
        }

        // Determine highlighting and error messages for calculated properties
        const isNZero = data.n.equals(0); // Should not happen for CNG predictions with hardcoded large N, but for safety

        const predictedMeVHTML = data.predictedMeV; // No green highlight for predictions unless they match something known, which isn't implemented
        const predictedKgHTML = data.predictedKg;
        const curvatureHTML = data.curvature;
        const redshiftHTML = data.redshift;
        const decoherenceTimeHTML = data.decoherenceTime;
        const entropyHTML = data.entropy;
        const shellLayerHTML = data.shellLayer;
        const predictedSpinHTML = data.predictedSpin; // No green highlight for predictions unless they match something known

        // Add on-screen error messages for N/A values
        const predictedMeVError = data.predictedMeV === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const predictedKgError = data.predictedKg === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const curvatureError = data.curvature === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const redshiftError = data.redshift === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const decoherenceTimeError = data.decoherenceTime === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const entropyError = data.entropy === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const shellLayerError = data.shellLayer === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';
        const predictedSpinError = data.predictedSpin === 'N/A' ? `<span class="error-message"> (Error)</span>` : '';


         // Build the display HTML
        let displayHTML = `
            <strong>${data.particleName}</strong><br>
            Mode Index (n): ${displayN}<br> Predicted Mass (MeV): ${predictedMeVHTML} MeV${predictedMeVError}<br>
            Predicted Mass (kg): ${predictedKgHTML} kg${predictedKgError}<br>
            Time-Curvature Mode κ<sub>n</sub> (unitless): ${curvatureHTML}${curvatureError}<br>
            Redshift Origin (z): ${redshiftHTML}${redshiftError}<br>
            Quantum Decoherence Time (τ<sub>D</sub>) (fs): ${decoherenceTimeHTML}${decoherenceTimeError}<br>
            Entropy Contribution (S<sub>n</sub>) (J/K): ${entropyHTML}${entropyError}<br>
            Resonance Shell Layer k: ${shellLayerHTML}${shellLayerError}${data.shellMatchNote}<br>
            Predicted Spin (CNG Winding): ${predictedSpinHTML} ${spinDescription}${predictedSpinError}<br> Charge (Placeholder/Manual Entry): ${data.charge} ${valleyStatus}
        `;

        document.getElementById("display").innerHTML = displayHTML;


         // Log any NaN or Infinity values for this prediction
        if (data.predictedMeV === 'N/A' || data.predictedKg === 'N/A' || data.curvature === 'N/A' || data.redshift === 'N/A' || data.decoherenceTime === 'N/A' || data.entropy === 'N/A' || data.shellLayer === 'N/A' || data.predictedSpin === 'N/A') {
             console.error(`Calculation error for ${name}. Check individual property values.`);
        }

    } catch (error) {
        console.error("Error displaying CNG Prediction", name, "data:", error);
        document.getElementById("display").innerHTML = `<strong class="text-red-500">Error displaying data for ${name}. Please check console for details.</strong>`;
    }
}


// Function to handle custom mode index input (triggered by left button)
function customN() {
    try { // Added try-catch for error isolation
        const nInput = prompt("Enter mode index n:");
        if (nInput === null) return; // User cancelled prompt

        let n;
        try {
            n = new Decimal(nInput);
        } catch (e) {
            // Handle Decimal.js parsing errors
            alert("Invalid input. Please enter a valid number.");
            console.error("Decimal.js parsing error for custom input:", e);
            return;
        }

        // Add more robust validation for custom input
        if (!n.isFinite() || n.lt(0)) { // Check for non-finite or negative
            alert("Invalid input. Please enter a non-negative finite number.");
            console.error("Invalid custom input: not finite or negative.", n);
            return;
        }

        // Add checks for extremely large/small values that might cause issues
        if (n.abs().gt(N_MAX_LIMIT)) {
             alert(`Input too large. Please enter a value less than or equal to ${N_MAX_LIMIT.toExponential()}.`);
             console.error("Invalid custom input: exceeds max limit.", n);
             return;
        }
         if (n.abs().lt(N_MIN_LIMIT) && !n.equals(0)) {
             alert(`Input too small. Please enter a value greater than or equal to ${N_MIN_LIMIT.toExponential()} or exactly 0.`);
             console.error("Invalid custom input: below min limit (and not zero).", n);
             return;
         }


        // For custom N, we assume it's a fundamental mode unless specified otherwise
        const data = getParticleData({ n: n }); // Pass an object like particleData


         // Display a fixed placeholder for the mode index in the main display
        const displayN = "[See list on right]"; // Reverted to placeholder

        let spinDescription = '';
         // Use the predictedSpin string directly
         if (data.predictedSpin.includes('0.5')) {
            spinDescription = '— matter-like'; // Use "matter-like" for custom 0.5
        } else if (data.predictedSpin.includes('1')) {
            spinDescription = '— force carrier-like'; // Use "force carrier-like" for custom 1
        } else if (data.predictedSpin.includes('Boson (n=0)')) {
             spinDescription = '— boson (n=0)';
        }


        let valleyStatus = '';
         // Only check for resonant valley if predicted values are finite
        if (isResonantValley(data.n) && typeof data.predictedMeV !== 'string' && typeof data.predictedKg !== 'string' && isFinite(parseFloat(data.predictedMeV)) && isFinite(parseFloat(data.predictedKg))) {
            valleyStatus = `<br><strong class="text-[#66fcf1]">Resonant Stability Valley ✔ (Expected longer lifetime/stable decay)</strong>`;
        }

        // Determine highlighting and error messages for calculated properties
        const isNZero = data.n.equals(0);

        const predictedMeVHTML = typeof data.predictedMeV === 'string' ? data.predictedMeV : (isNZero && (data.predictedMeV === '0.000000e+0' || data.predictedMeV === 'N/A') ? `<span class="highlight-green">${data.predictedMeV}</span>` : data.predictedMeV);
        const predictedKgHTML = typeof data.predictedKg === 'string' ? data.predictedKg : (isNZero && (data.predictedKg === '0.000000e+0' || data.predictedKg === 'N/A') ? `<span class="highlight-green">${data.predictedKg}</span>` : data.predictedKg);
        const curvatureHTML = typeof data.curvature === 'string' ? data.curvature : (isNZero && (data.curvature === '0.000000e+0' || data.curvature === 'N/A') ? `<span class="highlight-green">${data.curvature}</span>` : data.curvature);
        const redshiftHTML = typeof data.redshift === 'string' ? data.redshift : (isNZero && (data.redshift === '0.000000e+0' || data.redshift === 'N/A') ? `<span class="highlight-green">${data.redshift}</span>` : data.redshift);
        const decoherenceTimeHTML = typeof data.decoherenceTime === 'string' ? data.decoherenceTime : (isNZero && (data.decoherenceTime === '0.000000e+0' || data.decoherenceTime === 'N/A') ? `<span class="highlight-green">${data.decoherenceTime}</span>` : data.decoherenceTime);
        const entropyHTML = typeof data.entropy === 'string' ? data.entropy : (isNZero && (data.entropy === '0.000000e+0' || data.entropy === 'N/A') ? `<span class="highlight-green">${data.entropy}</span>` : data.entropy);
        const shellLayerHTML = typeof data.shellLayer === 'string' ? data.shellLayer : (isNZero && (data.shellLayer === '0' || data.shellLayer === 'N/A') ? `<span class="highlight-green">${data.shellLayer}</span>` : data.shellLayer);
        // Highlight predicted spin for custom input if it's 0.5 or 1 (based on the new mapping)
        const predictedSpinHTMLDisplay = (data.predictedSpin.includes('0.5') || data.predictedSpin.includes('1')) ? `<span class="highlight-green">${data.predictedSpin}</span>` : data.predictedSpin;


        // Add on-screen error messages for N/A values only if n > 0 or if n=0 but the value wasn't 0/N/A
        const predictedMeVError = data.predictedMeV === 'N/A' && !(isNZero && (data.predictedMeV === '0.000000e+0' || data.predictedMeV === 'N/A')) && typeof data.predictedMeV !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const predictedKgError = data.predictedKg === 'N/A' && !(isNZero && (data.predictedKg === '0.000000e+0' || data.predictedKg === 'N/A')) && typeof data.predictedKg !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const curvatureError = data.curvature === 'N/A' && !(isNZero && (data.curvature === '0.000000e+0' || data.curvature === 'N/A')) && typeof data.curvature !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const redshiftError = data.redshift === 'N/A' && !(isNZero && (data.redshift === '0.000000e+0' || data.redshift === 'N/A')) && typeof data.redshift !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const decoherenceTimeError = data.decoherenceTime === 'N/A' && !(isNZero && (data.decoherenceTime === '0.000000e+0' || data.decoherenceTime === 'N/A')) && typeof data.decoherenceTime !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const entropyError = data.entropy === 'N/A' && !(isNZero && (data.entropy === '0.000000e+0' || data.entropy === 'N/A')) && typeof data.entropy !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const shellLayerError = data.shellLayer === 'N/A' && !(isNZero && (data.shellLayer === '0' || data.shellLayer === 'N/A')) && typeof data.shellLayer !== 'string' ? `<span class="error-message"> (Error)</span>` : '';
        const predictedSpinError = data.predictedSpin === 'N/A' ? `<span class="error-message"> (Error)</span>` : ''; // Spin N/A is always an error


        // Build the display HTML
        let displayHTML = `
            <strong>${data.particleName}</strong><br>
            Mode Index (n): ${displayN}<br> Predicted Mass (MeV): ${predictedMeVHTML} MeV${predictedMeVError}<br>
            Predicted Mass (kg): ${predictedKgHTML} kg${predictedKgError}<br>
            Time-Curvature Mode κ<sub>n</sub> (unitless): ${curvatureHTML}${curvatureError}<br>
            Redshift Origin (z): ${redshiftHTML}${redshiftError}<br>
            Quantum Decoherence Time (τ<sub>D</sub>) (fs): ${decoherenceTimeHTML}${decoherenceTimeError}<br>
            Entropy Contribution (S<sub>n</sub>) (J/K): ${entropyHTML}${entropyError}<br>
            Resonance Shell Layer k: ${shellLayerHTML}${shellLayerError}${data.shellMatchNote}<br>
            Predicted Spin (CNG Winding): ${predictedSpinHTMLDisplay} ${spinDescription}${predictedSpinError}<br> Charge (Placeholder/Manual Entry): ${data.charge} ${valleyStatus} `;

        document.getElementById("display").innerHTML = displayHTML;


         // Log any NaN or Infinity values for this custom mode
        if (typeof data.predictedMeV !== 'string' && typeof data.predictedKg !== 'string' && typeof data.curvature !== 'string' && typeof data.redshift !== 'string' && typeof data.decoherenceTime !== 'string' && typeof data.entropy !== 'string' && typeof data.shellLayer !== 'string' && data.predictedSpin !== 'N/A') {
            if (data.predictedMeV === 'N/A' || data.predictedKg === 'N/A' || data.curvature === 'N/A' || data.redshift === 'N/A' || data.decoherenceTime === 'N/A' || data.entropy === 'N/A' || data.shellLayer === 'N/A' || data.predictedSpin === 'N/A') {
                 console.error(`Calculation error for custom mode (n=${nInput}). Check individual property values.`);
            }
        } else if (typeof data.predictedMeV === 'string' || typeof data.predictedKg === 'string' || typeof data.curvature === 'string' || typeof data.redshift === 'string' || typeof data.decoherenceTime === 'string' || typeof data.entropy === 'string' || typeof data.shellLayer === 'string' || data.predictedSpin === 'N/A') {
             // Log if any of the values are placeholder strings
             console.log(`Custom mode (n=${nInput}) displayed placeholders or N/A values.`);
        }


    } catch (error) {
        console.error("Error calculating custom mode data:", error);
        document.getElementById("display").innerHTML = `<strong class="text-red-500">Error calculating custom mode data. Please check console for details.</strong>`;
    }
}

// Function to clear the display screen (triggered by left button)
function clearDisplay() {
    document.getElementById("display").innerText = "Select a particle or prediction to view data.";
}

// Function to toggle the visibility of the formula display
function showFormula() {
    const formulaDisplay = document.getElementById("formulaDisplay");
    if (formulaDisplay) {
        formulaDisplay.classList.toggle('hidden'); // Use Tailwind's hidden class
        // Trigger MathJax typesetting when the formula display becomes visible
        if (!formulaDisplay.classList.contains('hidden')) {
            MathJax.typesetPromise([formulaDisplay]).catch((err) => console.error('MathJax typesetting failed', err));
        }
    }
}

// Function to render the particle buttons and CNG prediction buttons in the left section
function renderButtons() {
    try {
        const grid = document.getElementById("buttonGrid");
        if (!grid) {
            console.error("Button grid element not found!");
            return; // Cannot render buttons if the grid doesn't exist
        }
        grid.innerHTML = ''; // Clear existing buttons

        console.log("Starting to render particle buttons..."); // Added log

        // Render standard particle buttons (including composites)
        Object.keys(allParticleData).forEach(p => {
            try { // Added inner try-catch for each particle button
                console.log(`Rendering button for: ${p}`); // Added log for particle being processed
                const btn = document.createElement("button");
                btn.textContent = p;
                // Add Tailwind classes for styling
                btn.classList.add('p-3', 'rounded-lg', 'font-bold', 'bg-[#c5c6c7]', 'text-[#1f2833]','hover:bg-[#66fcf1]', 'transition', 'duration-200');
                // Wrap the onclick handler in a try-catch
                btn.onclick = () => {
                    try {
                         showParticle(p); // showParticle can now handle all entries in allParticleData
                    } catch (error) {
                        console.error("Error handling click for button", p, ":", error);
                        document.getElementById("display").innerHTML = `<strong class="text-red-500">Error displaying data for ${p}. Please check console for details.</strong>`;
                    }
                };
                grid.appendChild(btn);
                console.log(`Successfully rendered button for: ${p}`); // Added success log
            } catch (innerError) {
                console.error(`Error rendering button for particle ${p}:`, innerError); // Log specific particle error
                 // Optionally, add a placeholder or skip this button
                 const errorDiv = document.createElement("div");
                 errorDiv.textContent = `Error loading ${p}`;
                 errorDiv.style.color = 'red';
                 grid.appendChild(errorDiv);
            }
        });

        console.log("Finished rendering buttons."); // Added log

    } catch (error) {
        console.error("Error rendering buttons:", error);
        // If button rendering itself fails, display a general error
         const grid = document.getElementById("buttonGrid");
         if (grid) {
              grid.innerHTML = `<strong class="text-red-500">Error loading calculator buttons. Please check console for details.</strong>`;
         }
    }
}

// Function to render the clickable mode indices list in the right section
function renderModeIndicesList() {
    try {
        const modeIndicesListContainer = document.getElementById("modeIndicesListContainer");
        if (!modeIndicesListContainer) return;

        console.log("Rendering mode indices list..."); // Log start of list rendering

        // Clear existing content except the strong tag title
        const titleTag = modeIndicesListContainer.querySelector('strong');
        modeIndicesListContainer.innerHTML = '';
        if (titleTag) {
            modeIndicesListContainer.appendChild(titleTag);
        } else {
             // If title wasn't found, add it back
             const strongTag = document.createElement('strong');
             strongTag.classList.add('text-[#66fcf1]', 'text-base', 'block', 'mb-2');
             strongTag.textContent = 'Refined Mode Indices (n):';
             modeIndicesListContainer.appendChild(strongTag);
        }

        // Use allParticleData to render the full list
        Object.keys(allParticleData).forEach(pName => {
            const p = allParticleData[pName];
            console.log(`Adding ${pName} to the mode indices list.`); // Log each particle added

            // Create a container for each particle item
            const itemContainer = document.createElement("div");
            itemContainer.classList.add('mode-index-item-container');

            // Create the clickable particle name element
            const nameDiv = document.createElement("div");
            nameDiv.classList.add('mode-index-item'); // Add class for styling and targeting
            nameDiv.textContent = pName; // Display particle name
            nameDiv.dataset.particleName = pName; // Store particle name for click handling

            // Create the hidden div for displaying the full index
            const fullIndexDiv = document.createElement("div");
            fullIndexDiv.classList.add('full-index-display'); // Add class for styling and targeting

            // Append name and full index div to the item container
            itemContainer.appendChild(nameDiv);
            itemContainer.appendChild(fullIndexDiv);

            // Append the item container to the main list container
            modeIndicesListContainer.appendChild(itemContainer);
        });
         console.log("Finished rendering mode indices list items."); // Log end of list item rendering


        // Add click event listener to the main mode indices list container
        modeIndicesListContainer.addEventListener('click', function(event) {
            try { // Added try-catch for error isolation
                const target = event.target;
                // Check if the clicked element is a particle name item
                if (target && target.classList.contains('mode-index-item')) {
                    const particleName = target.dataset.particleName;
                    if (particleName && allParticleData[particleName]) { // Use allParticleData here
                        displayFullModeIndex(target.closest('.mode-index-item-container'), particleName); // Pass the container and name
                    }
                } else {
                    // If click is not on an item, hide all full displays
                    hideAllFullModeIndices();
                }
            } catch (error) {
                console.error("Error in modeIndicesListContainer click handler:", error);
                // No specific display update for this error, as it's in the list interaction
            }
        });
         console.log("Mode indices list click handler added."); // Log handler added

    } catch (error) {
        console.error("Error rendering mode indices list:", error);
         // If list rendering itself fails, display a general error
         const modeIndicesListContainer = document.getElementById("modeIndicesListContainer");
         if (modeIndicesListContainer) {
              modeIndicesListContainer.innerHTML = `<strong class="text-red-500">Error loading mode indices list. Please check console for details.</strong>`;
         }
    }
}

// Function to display the full mode index for a selected particle, under its name
function displayFullModeIndex(itemContainer, particleName) {
    try { // Added try-catch for error isolation
        const fullDisplayElement = itemContainer.querySelector('.full-index-display');
        const particle = allParticleData[particleName]; // Use allParticleData here

        if (fullDisplayElement && particle) {
            // Hide any currently displayed full indices first
            hideAllFullModeIndices();

            // Display the full, unrounded mode index
            fullDisplayElement.innerHTML = `<strong>Mode Index (n):</strong> ${particle.n.toString()}`;
            fullDisplayElement.style.display = 'block'; // Show the element
        }
    } catch (error) {
         console.error("Error displaying full mode index for", particleName, ":", error);
         // No specific display update for this error, as it's in the list interaction
    }
}

// Function to hide all currently displayed full mode indices
function hideAllFullModeIndices() {
    const allFullDisplays = document.querySelectorAll('.full-index-display');
    allFullDisplays.forEach(el => {
        el.style.display = 'none';
        el.innerHTML = ''; // Clear content when hidden
    });
}


// Function to check if a mode index is in a resonant stability valley (based on second derivative of mass)
function isResonantValley(n) {
    // Use a relative delta based on n for better accuracy with large numbers
    // Ensure n is a positive finite number before calculating delta
     if (!n.isFinite() || n.lt(0)) {
        return false; // Cannot calculate derivative for non-finite or negative n
    }
    const delta = n.times("1e-6");


    // Ensure n +/- delta are positive for curvatureKappa
    if (n.minus(delta).lte(0) || n.plus(delta).lte(0)) {
        return false; // Cannot calculate derivative if n is too small
    }

    const m1 = massMeV(n.minus(delta));
    const m2 = massMeV(n);
    const m3 = massMeV(n.plus(delta));

    // Check for NaN or Infinity results from massMeV
    if (m1.isNaN() || !m1.isFinite() || m2.isNaN() || !m2.isFinite() || m3.isNaN() || !m3.isFinite()) {
        return false;
    }

    // Approximate the second derivative using Decimal objects
    const d2 = (m1.minus(m2.times(2)).plus(m3)).div(delta.times(delta));

    // Define a tolerance for considering it a "valley" (where the second derivative is close to zero)
    // The specific tolerance might need tuning based on the function's behavior
    const valleyTolerance = new Decimal("1e-3"); // Example tolerance - adjust as needed

    // A valley corresponds to a local local minimum or inflection point where the second derivative is close to zero.
    // For a "stability valley", we might also expect the first derivative to be close to zero (local minimum).
    // Let's focus on the second derivative being close to zero for now.
     return d2.abs().lt(valleyTolerance);
}


// Initial rendering of buttons and mode indices list when the page loads
try {
    renderButtons();
    renderModeIndicesList();
} catch (error) {
    console.error("Error during initial rendering:", error);
}
</script>
</html>
